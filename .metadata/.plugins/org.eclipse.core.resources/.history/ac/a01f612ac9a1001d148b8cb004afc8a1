package rs.ac.bg.etf.pp1;

import org.apache.log4j.Logger;

import java.util.ArrayList;
import java.util.Stack;
import java.util.Iterator;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;

public class SemanticAnalyzer extends VisitorAdaptor {

	public static Struct boolType = Tab.insert(Obj.Type, "bool", new Struct(Struct.Bool)).getType();

	private int nVars;
	private boolean isMainDefined = false;
	
	private Obj currentClass = null;
	
	private Obj currentMethod = null;
	private Stack<ArrayList<Struct>> actualParametersListStack = new Stack<>();
	private Struct returnType = null;

	private boolean isProgDeclaration = false;
	private Struct declarationType = null;

	private ArrayList<Struct> currentlyDeclaredVariables = new ArrayList<>();

	Logger log = Logger.getLogger(getClass());

	private boolean errorDetected = false;
	
	public boolean passed() {
		return !errorDetected;
	}
	
	public int getNVars() {
		return nVars;
	}
	
	public boolean isCurrVarField() {
		return currentClass != null && currentMethod == null;
	}

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0 : info.getLine();
		if (line != 0)
			msg.append(" na liniji ").append(line);
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0 : info.getLine();
		if (line != 0)
			msg.append(" na liniji ").append(line);
		log.info(msg.toString());
	}

	/* Program grammar, global declarations (const, variable, class)*/
	// TODO: Class
	public void visit(Program program) {
		if (!isMainDefined) {
			report_error("Semanticka greska: Program mora imati definisanu main() metodu!", program);
		}
		nVars = Tab.currentScope.getnVars();
		Tab.chainLocalSymbols(program.getProgName().obj);
		Tab.closeScope();
	}

	public void visit(ProgName progName) {
		progName.obj = Tab.insert(Obj.Prog, progName.getPName(), Tab.noType);
		Tab.openScope();
	}

	public void visit(ProgVarType type) {
		isProgDeclaration = true;
	}

	public void visit(ProgVarDeclarationStart progVarDeclaration) {
		isProgDeclaration = false;
		declarationType = null;
	}

	public void visit(ConstDeclaration constDecl) {
		if (Tab.find(constDecl.getConstName()) != Tab.noObj) {
			report_error("Semanticka greska: Konstanta " + constDecl.getConstName() + " je vec deklarisana!",
					constDecl);
			return;
		}
		if (constDecl.getConstType().struct.assignableTo(declarationType)) {
			// TODO: U 4. fazi dodeli odgovarajucu vrednost konstanti!
			Tab.insert(Obj.Con, constDecl.getConstName(), declarationType);
			report_info("Definisana const", constDecl);
		} else {
			report_error("Semanticka greska: Tip konstante i dodeljena vrednost su nekompatibilne!", constDecl);
		}
	}
	
	public void visit(ConstDeclarationStart constStart) {
		declarationType = null;
	}

	/* Standard types: int, char, bool */
	public void visit(ConstIntType cnstInt) {
		cnstInt.struct = Tab.intType;
	}

	public void visit(ConstCharType cnstChar) {
		cnstChar.struct = Tab.charType;
	}

	public void visit(ConstBoolType cnstBool) {
		cnstBool.struct = boolType;
	}
	
	/* Array and normal variables checks */
	public void visit(VarDeclarationStart varStart) {
		declarationType = null;
	}
	
	public void visit(VarNameSingle var) {
		Obj obj = Tab.currentScope.findSymbol(var.getVarName());
		if (obj != Tab.noObj) {
			report_error("Semanticka greska: Varijabla " + var.getVarName() + " je vec deklarisana u opsegu!", var);
			return;
		}
		if (isCurrVarField()) {
			Tab.insert(Obj.Fld, var.getVarName(), declarationType);
			report_info("Definicija polja", var);
		}
		else {
			Tab.insert(Obj.Var, var.getVarName(), declarationType);
			report_info("Definicija promenljive", var);
		}
	}

	public void visit(VarNameArray var) {
		Obj obj = Tab.currentScope.findSymbol(var.getVarName());
		if (obj != Tab.noObj) {
			report_error("Semanticka greska: Varijabla " + var.getVarName() + " je vec deklarisana!", var);
			return;
		}
		if (isCurrVarField())
		{			
			Tab.insert(Obj.Fld, var.getVarName(), new Struct(Struct.Array, declarationType));
			report_info("Definicija niz polja", var);
		}
		else {
			Tab.insert(Obj.Var, var.getVarName(), new Struct(Struct.Array, declarationType));
			report_info("Definicija niz promenljive", var);
		}
		
	}
	
	/* Type */
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getTypeName());
		if (typeObj == Tab.noObj) {
			report_error("Semanticka greska: Nije pronadjen tip" + type.getTypeName() + "u tabeli simbola!", null);
			type.struct = Tab.noType;
			declarationType = Tab.noType;
		} else if (Obj.Type != typeObj.getKind()) {
			report_error("Semanticka greska: " + type.getTypeName() + "ne predstavlja nijedan postojeci tip!", type);
			type.struct = Tab.noType;
			declarationType = Tab.noType;
		} else {
			type.struct = typeObj.getType();
			declarationType = typeObj.getType();
		}
	}
	
	/* Class */
	public void visit(ClassName clsName) {
		currentClass = Tab.insert(Obj.Type, clsName.getName(), new Struct(Struct.Class));
		Tab.openScope();
		Tab.insert(Obj.Fld, "$tvf" + clsName.getName(), Tab.nullType); // + clsName.getName()
	}
	
	public void visit(ProgClassDecl classDecl) {
		Struct superClass = currentClass.getType().getElemType();
		if (superClass != null) {
			for (Obj classMember : superClass.getMembers()) {
				if (classMember.getKind() == Obj.Fld && !classMember.getName().startsWith("$tvf")) { // "$vtf".equals(classMember.getName())
//					Tab.currentScope().addToLocals(obj);
					// TODO: Ovo ce morati da se proveri, ali polako (da li treba i metode, kako promeniti "this" od natklase?)!
					Tab.insert(Obj.Fld, classMember.getName(), classMember.getType());
				}
			}
		}
		
		Tab.chainLocalSymbols(currentClass.getType());
		Tab.closeScope();
		
		currentClass = null;
	}
	
	public void visit(SuperClassIdent sup) {
		Obj obj = Tab.find(sup.getName());
		if (obj != Tab.noObj && obj.getType().getKind() == Struct.Class) {
			if (obj.getName() != currentClass.getName()) {
				currentClass.getType().setElementType(obj.getType());
			}
			else {
				report_error("Semanticka greska: Klasa se ne moze izvoditi iz sama sebe!", sup);
			}
		}
		else {
			report_error("Semanticka greska: Klasa iz koje se pokusava izvodjenje je nepostojeca!", sup);
		}
	}
	
	/* Methods */
	private void processMethodAndTypeName(MethodTypeAndName method, Struct type, String methName) {
		method.obj = currentMethod = Tab.insert(Obj.Meth, 
				methName, type);
		
		Tab.openScope();
		
		if (currentClass != null) {
			Tab.insert(Obj.Var, "this", currentClass.getType());
		}
	}
	
	public void visit(MethodTypeName method) {
		Struct type = method.getType().struct;
		processMethodAndTypeName(method, type, method.getMethName());
	}
	
	public void visit(MethodVoidName method) {
		processMethodAndTypeName(method, Tab.noType, method.getMethName());
	}
	
	public void visit(MethodDecl methodDeclaration) {
		if (returnType == null && currentMethod.getType() != Tab.noType) {
			report_error("Semanticka greska: Nije pronadjen return tipa " 
						+ currentMethod.getType().getKind(), methodDeclaration);
		}
		
		Tab.chainLocalSymbols(currentMethod);
		Tab.closeScope();
		
		returnType = null;
		currentMethod = null;
	}
	
	/* Return statements */
	public void visit(ReturnStatement ret) {
		if (currentMethod == null) {
			report_error("Semanticka greska: return pronadjen van funkcije!", ret);
		}
		if (currentMethod == null && currentMethod.getType() != Tab.noType) {
			report_error("Semanticka greska: return vraca nekompatibilan tip!", ret);
		}
	}
	
	public void visit(ReturnExprStatement ret) {
		if (currentMethod == null) {
			report_error("Semanticka greska: return pronadjen van funkcije!", ret);
		}
		if (currentMethod == null && !ret.getExpr().struct.compatibleWith(currentMethod.getType())) {
			report_error("Semanticka greska: return vraca nekompatibilan tip!", ret);
		}
		returnType = ret.getExpr().struct;
	}
	
	/* Formal parameters */
	public void visit(FormalParamDeclSingle formalParam) {
		Obj obj = Tab.currentScope.findSymbol(formalParam.getName());
		if (obj != Tab.noObj && obj != null) {
			report_error("Semanticka greska: vec postoji formalni parametar sa istim imenom!", formalParam);
		}
		Tab.insert(Obj.Var, formalParam.getName(), 
				formalParam.getType().struct);
	}
	
	public void visit(FormalParamDeclArray formalParam) {
		Obj obj = Tab.currentScope.findSymbol(formalParam.getName());
		if (obj != Tab.noObj && obj != null) {
			report_error("Semanticka greska: vec postoji formalni parametar sa istim imenom!", formalParam);
		}
		Tab.insert(Obj.Var, formalParam.getName(), 
				new Struct(Struct.Array, formalParam.getType().struct));
	}
	
	public void visit(OptFormalParams formalParamList) {
		int numberOfParameters = Tab.currentScope.getnVars();
		if (currentClass != null) {
			// Excluding this parameter
			currentMethod.setLevel(numberOfParameters - 1);
		}
		else {
			currentMethod.setLevel(numberOfParameters);
		}
	}
	
	public void visit(FunctionName funcName) {
		if (funcName.getDesignator().obj.getKind() != Obj.Meth) {
			report_error("Semanticka greska: designator ne predstavlja ime funkcije!", funcName);
		}
		actualParametersListStack.push(new ArrayList<Struct>()));
	}
	
	/* Designator, DesignatorStatement (everything where it is involved) */
	public void visit(DesignatorSingle designator) {
		Obj obj = Tab.find(designator.getName());
		
		if (obj == Tab.noObj) {
			report_error("Promenljiva " + designator.getName() + " nije deklarisana!", designator);
		}
		designator.obj = obj;
	}
	
	public void visit(DesignatorArray designator) {
		Obj obj = designator.getDesignator().obj;
		if (obj.getType().getKind() != Struct.Array) {
			report_error("Semanticka greska: Promenljiva " + obj.getName() + " mora biti tipa niz!", designator);
			designator.obj = Tab.noObj;
			return;
		}
		if (designator.getExpr().struct != Tab.intType) {
			report_error("Semanticka greska: Indeks niza mora biti tipa int!", designator);
			designator.obj = Tab.noObj;
			return;
		}
		
		// Changing objects type from Array type to Elem type
		designator.obj = new Obj(Obj.Elem, designator.getDesignator().obj.getName(), 
				designator.getDesignator().obj.getType().getElemType());
	}
	
//	public void visit(DesignatorField designator) {
//		// TODO: Posle generisanja koda za ostalo, za sad nema smisla...
//	}
	
	public void visit(AssignmentExpr ass) {
		Struct expressionStruct = ass.getExpr().struct;
		Struct designatorStruct = ass.getDesignator().obj.getType();
		int expressionKind = ass.getExpr().struct.getKind();
		int designatorKind = ass.getDesignator().obj.getKind();
		
		
		if (expressionKind == Struct.Class) {
			// TODO: Slucaj ako je tip klase, pretraga superklasa		
		}
		else {
			if (expressionStruct.assignableTo(designatorStruct)) {
				report_error("Semanticka greska: Izraz je nemoguce dodeliti dezignatoru!", ass);
			}
			else {
				int kind = ass.getDesignator().obj.getKind();
				if (designatorKind != Obj.Var && designatorKind != Obj.Fld 
						&& designatorKind != Obj.Elem) {
					report_error("Semanticka greska: Dezignatoru se ne moze dodeliti nova vrednost!", ass);
				}
			}
			ass.struct = ass.getDesignator().obj.getType();
		}
	}
	
	// Increment and decrement
	private void checkIncrementAndDecrement(SyntaxNode node, int kind, Struct type, String op) {
		if (kind != Obj.Var && kind != Obj.Fld && kind != Obj.Elem) {
			report_error("Semanticka greska: Dezignator nije odgovarajuce vrste za operaciju " + op + "!", node);
		}
		if (type != Tab.intType) {
			report_error("Semanticka greska: Dezignatoru mora biti tipa int za " + op +"!", node);
		}
	}
	
	public void visit(IncrementDesignator incDesignator) {
		int kind = incDesignator.getDesignator().obj.getKind();
		Struct type = incDesignator.getDesignator().obj.getType();
		checkIncrementAndDecrement(incDesignator, kind, type, "inkrement");
	}
	
	public void visit(DecrementDesignator decDesignator) {
		int kind = decDesignator.getDesignator().obj.getKind();
		Struct type = decDesignator.getDesignator().obj.getType();
		checkIncrementAndDecrement(decDesignator, kind, type, "dekrement");
	}
	
	// Function designator
	public void visit(ActualParamSingle actualParam) {
		actualParametersListStack.peek().add(actualParam.getActualParameter().getExpr().struct);
	}
	
	public void visit(ActualParamListRec actualParam) {
		actualParametersListStack.peek().add(actualParam.getActualParameter().getExpr().struct);
	}
	
	public void visit(FunctionCall functionCall) {
		Obj functionDesignator = functionCall.getFunctionName().getDesignator().obj;
		ArrayList<Struct> actualParametersList = actualParametersListStack.pop();
		
		if (functionDesignator.getKind() != Obj.Meth) {
			report_error("Semanticka greska: Dezignator ne predstavlja ime funkcije i ne moze se pozvati!", functionCall);
			return;
		}
		
		
		
	}
	
	/* Expr, term, factor */
	public void visit(DesignatorFactor desFactor) {
		int kind = desFactor.getDesignator().obj.getKind();
		if (kind == Obj.Meth) {
			desFactor.struct = Tab.noType;
		}
		else {			
			desFactor.struct = desFactor.getDesignator().obj.getType();
		}
	}
	
	public void visit(FactorFuncCall funcCall) {
		Obj obj = funcCall.getFunctionCall().getFunctionName().getDesignator().obj;
		if (obj.getType() == Tab.noType) {
			report_error("Semanticka greska: void funkcija se ne sme koristiti u okviru izraza!", funcCall);
		}
		funcCall.struct = funcCall.getFunctionCall().struct;
	}
	
	public void visit(ConstFactor cnstFactor) {
		cnstFactor.struct = cnstFactor.getConstType().struct;
	}
	
	public void visit(ExprFactor exprFactor) {
		exprFactor.struct = exprFactor.getExpr().struct;
	}
	
	// TODO: Moguce prepravljanje zbog generisanja koda!
	public void visit(OperatorNewClass newClass) {
		Struct type = newClass.getType().struct;
		if (type.getKind() != Struct.Class) {
			report_error("Semanticka greska: tip uz new mora biti klasa!", newClass);
		}
		newClass.struct = type;
	}
	
	public void visit(OperatorNewArr newArr) {
		Struct type = newArr.getType().struct;
		
		if (newArr.getExpr().struct == Tab.intType) {
			newArr.struct = new Struct(Struct.Array, type);
		}
		else {
			report_error("Semanticka greska: Velicina niza mora biti tipa int!", newArr);
			// Za slucaj greske, propagirati
			newArr.struct = type;
		}
	}
	
	public void visit(FactorTerm factorTerm) {
		factorTerm.struct = factorTerm.getFactor().struct;
	}
	
	public void visit(MulTerm mulExpr) {
		if (!mulExpr.getTerm().struct.compatibleWith(mulExpr.getFactor().struct)) {
			report_error("Semanticka greska: Nekompatibilni podaci pri racunanju izraza!", mulExpr);
		}
		mulExpr.struct = mulExpr.getTerm().struct;
	}
	
	public void visit(TermExpr termExpr) {
		termExpr.struct = termExpr.getTerm().struct;
	}
	
	public void visit(NegExpr negExpr) {
		negExpr.struct = negExpr.getTerm().struct;
	}
	
	public void visit(AddExpr addExpr) {
		if (!addExpr.getExpr().struct.compatibleWith(addExpr.getTerm().struct)) {
			report_error("Semanticka greska: Nekompatibilni podaci pri racunanju izraza!", addExpr);
		}
		
		addExpr.struct = addExpr.getExpr().struct;
	}
	
	
	
	/* Read and Print */
	public void visit(PrintStatement prntStmt) {
		Struct type = prntStmt.getExpr().struct;
		if (type != Tab.charType && type != Tab.intType && type != boolType)
			report_error("Semanticka greska: Nekompatibilni tipovi za print!", prntStmt);
	}
	
	public void visit(PrintWidthStatement prntStmt) {
		Struct type = prntStmt.getExpr().struct;
		if (type != Tab.charType && type != Tab.intType && type != boolType)
			report_error("Semanticka greska: Nekompatibilni tipovi za print!", prntStmt);
	}
	
	public void visit(ReadStatement rdStmt) {
		Obj obj = rdStmt.getDesignator().obj;
		if (obj.getKind() == Obj.Var 
				|| obj.getKind() == Obj.Fld || obj.getKind() == Obj.Elem) {
			Struct type = obj.getType();
			if (type != Tab.charType && type != Tab.intType && type != boolType)
				report_error("Semanticka greska: Nekompatibilni designator za read!", rdStmt);
		}
		else {
			report_error("Semanticka greska: Nekompatibilni designator za read!", rdStmt);
		}
	}
	
	
	/* Conditions */	
	public void visit(ConditionFactorSingle conditionFactor) {
		Struct type = conditionFactor.getExpr().struct;
		if (type != boolType) {
			report_error("Semanticka greska: Nekompatibilan tipa za uslov!", conditionFactor);
		}
		conditionFactor.struct = boolType;
	}
	
	public void visit(ConditionFactorRel conditionFactor) {
		Struct type_first = conditionFactor.getExpr().struct;
		Struct type_second = conditionFactor.getExpr1().struct;
		if (type_first == boolType || !type_first.compatibleWith(type_second)) {
			report_error("Semanticka greska: Nekompatibilni tipovi u relaciji!", conditionFactor);
		}
		conditionFactor.struct = boolType;
	}
	
	public void visit(ConditionTermSingle conditionTerm) {
		Struct type = conditionTerm.getConditionFactor().struct;
		if (type != boolType) {
			report_error("Semanticka greska: Nekompatibilan tipa za uslov!", conditionTerm);
		}
		conditionTerm.struct = boolType;
	}
	
	public void visit(ConditionTermAnd conditionTerm) {
		Struct type_first = conditionTerm.getConditionTerm().struct;
		Struct type_second = conditionTerm.getConditionFactor().struct;
		if (type_first == boolType || !type_first.compatibleWith(type_second)) {
			report_error("Semanticka greska: Nekompatibilni tipovi u relaciji!", conditionTerm);
		}
		conditionTerm.struct = boolType;
	}
	
	public void visit(ConditionSingle condition) {
		Struct type = condition.getConditionTerm().struct;
		if (type != boolType) {
			report_error("Semanticka greska: Nekompatibilan tipa za uslov!", condition);
		}
		condition.struct = boolType;
	}
	
	public void visit(ConditionOr condition) {
		Struct type_first = condition.getCondition().struct;
		Struct type_second = condition.getConditionTerm().struct;
		if (type_first == boolType || !type_first.compatibleWith(type_second)) {
			report_error("Semanticka greska: Nekompatibilni tipovi u relaciji!", condition);
		}
		condition.struct = boolType;
	}

}
