Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "COLON" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
------- ast extension v0.8 summary -------
  Generated 39 base classes
  Generated 101 derived classes
  Filling in tables...
  Generated 17 record classes
  Generated interface SyntaxNode
  Generated interface Visitor
  Generated adapter class VisitorAdaptor
*** Reduce/Reduce conflict found in state #68
  between FunctionName ::= Designator (*) 
-----------------------------------------------
  and     ForeachDesignator ::= Designator (*) 
  under symbols: {}
  Resolved in favor of the second production.

*** Shift/Reduce conflict found in state #68
  between FunctionName ::= Designator (*) 
  and     Designator ::= Designator (*) DOT IDENT 
  under symbol DOT
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #68
  between ForeachDesignator ::= Designator (*) 
  and     Designator ::= Designator (*) DOT IDENT 
  under symbol DOT
  Resolved in favor of shifting.

  Checking for non-reduced productions...
*** Production "ForeachDesignator ::= Designator " never reduced
*** More conflicts encountered than expected -- parser generation aborted
===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [$START ::= (*) Program EOF , {EOF }]
  [Program ::= (*) PROG ProgName ProgDeclList LBRACE MethodDeclList RBRACE , {EOF }]
}
transition on PROG to state [2]
transition on Program to state [1]

-------------------
lalr_state [1]: {
  [$START ::= Program (*) EOF , {EOF }]
}
transition on EOF to state [209]

-------------------
lalr_state [2]: {
  [ProgName ::= (*) IDENT , {LBRACE CONST IDENT CLASS }]
  [Program ::= PROG (*) ProgName ProgDeclList LBRACE MethodDeclList RBRACE , {EOF }]
}
transition on ProgName to state [4]
transition on IDENT to state [3]

-------------------
lalr_state [3]: {
  [ProgName ::= IDENT (*) , {LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [4]: {
  [ProgDeclList ::= (*) ProgDeclList ProgClassDecl , {LBRACE CONST IDENT CLASS }]
  [ProgDeclList ::= (*) ProgDeclList ProgVarDeclStart , {LBRACE CONST IDENT CLASS }]
  [ProgDeclList ::= (*) , {LBRACE CONST IDENT CLASS }]
  [Program ::= PROG ProgName (*) ProgDeclList LBRACE MethodDeclList RBRACE , {EOF }]
  [ProgDeclList ::= (*) ProgDeclList ConstDeclStart , {LBRACE CONST IDENT CLASS }]
}
transition on ProgDeclList to state [5]

-------------------
lalr_state [5]: {
  [ProgDeclList ::= ProgDeclList (*) ProgClassDecl , {LBRACE CONST IDENT CLASS }]
  [ProgVarType ::= (*) Type , {IDENT }]
  [ConstDeclStart ::= (*) CONST Type ConstList SEMI , {LBRACE CONST IDENT CLASS }]
  [ProgDeclList ::= ProgDeclList (*) ProgVarDeclStart , {LBRACE CONST IDENT CLASS }]
  [Type ::= (*) IDENT , {IDENT }]
  [ClassName ::= (*) CLASS IDENT , {LBRACE EXT }]
  [ProgVarDeclStart ::= (*) ProgVarType ProgVarList SEMI , {LBRACE CONST IDENT CLASS }]
  [Program ::= PROG ProgName ProgDeclList (*) LBRACE MethodDeclList RBRACE , {EOF }]
  [ProgDeclList ::= ProgDeclList (*) ConstDeclStart , {LBRACE CONST IDENT CLASS }]
  [ProgClassDecl ::= (*) ClassName OptionalClassExtends LBRACE VarDeclList ClassMethodDecl RBRACE , {LBRACE CONST IDENT CLASS }]
}
transition on CONST to state [15]
transition on CLASS to state [14]
transition on ProgVarType to state [13]
transition on ClassName to state [12]
transition on ProgVarDeclStart to state [11]
transition on ConstDeclStart to state [10]
transition on ProgClassDecl to state [9]
transition on IDENT to state [8]
transition on LBRACE to state [7]
transition on Type to state [6]

-------------------
lalr_state [6]: {
  [ProgVarType ::= Type (*) , {IDENT }]
}

-------------------
lalr_state [7]: {
  [MethodDeclList ::= (*) , {RBRACE VOID IDENT }]
  [Program ::= PROG ProgName ProgDeclList LBRACE (*) MethodDeclList RBRACE , {EOF }]
  [MethodDeclList ::= (*) MethodDeclList MethodDecl , {RBRACE VOID IDENT }]
}
transition on MethodDeclList to state [207]

-------------------
lalr_state [8]: {
  [Type ::= IDENT (*) , {LBRACKET LPAREN IDENT }]
}

-------------------
lalr_state [9]: {
  [ProgDeclList ::= ProgDeclList ProgClassDecl (*) , {LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [10]: {
  [ProgDeclList ::= ProgDeclList ConstDeclStart (*) , {LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [11]: {
  [ProgDeclList ::= ProgDeclList ProgVarDeclStart (*) , {LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [12]: {
  [OptionalClassExtends ::= (*) , {LBRACE }]
  [ProgClassDecl ::= ClassName (*) OptionalClassExtends LBRACE VarDeclList ClassMethodDecl RBRACE , {LBRACE CONST IDENT CLASS }]
  [OptionalClassExtends ::= (*) EXT SuperClass , {LBRACE }]
}
transition on OptionalClassExtends to state [39]
transition on EXT to state [38]

-------------------
lalr_state [13]: {
  [ProgVarList ::= (*) ProgVarDeclaration , {SEMI COMMA }]
  [ProgVarDeclStart ::= ProgVarType (*) ProgVarList SEMI , {LBRACE CONST IDENT CLASS }]
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [ProgVarList ::= (*) ProgVarList COMMA ProgVarDeclaration , {SEMI COMMA }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
  [ProgVarDeclaration ::= (*) VarName , {SEMI COMMA }]
}
transition on ProgVarDeclaration to state [32]
transition on IDENT to state [31]
transition on VarName to state [30]
transition on ProgVarList to state [29]

-------------------
lalr_state [14]: {
  [ClassName ::= CLASS (*) IDENT , {LBRACE EXT }]
}
transition on IDENT to state [28]

-------------------
lalr_state [15]: {
  [Type ::= (*) IDENT , {IDENT }]
  [ConstDeclStart ::= CONST (*) Type ConstList SEMI , {LBRACE CONST IDENT CLASS }]
}
transition on IDENT to state [8]
transition on Type to state [16]

-------------------
lalr_state [16]: {
  [ConstList ::= (*) ConstList COMMA ConstDeclaration , {SEMI COMMA }]
  [ConstDeclStart ::= CONST Type (*) ConstList SEMI , {LBRACE CONST IDENT CLASS }]
  [ConstDeclaration ::= (*) IDENT ASSIGN ConstType , {SEMI COMMA }]
  [ConstList ::= (*) ConstDeclaration , {SEMI COMMA }]
}
transition on ConstList to state [19]
transition on IDENT to state [18]
transition on ConstDeclaration to state [17]

-------------------
lalr_state [17]: {
  [ConstList ::= ConstDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [18]: {
  [ConstDeclaration ::= IDENT (*) ASSIGN ConstType , {SEMI COMMA }]
}
transition on ASSIGN to state [23]

-------------------
lalr_state [19]: {
  [ConstDeclStart ::= CONST Type ConstList (*) SEMI , {LBRACE CONST IDENT CLASS }]
  [ConstList ::= ConstList (*) COMMA ConstDeclaration , {SEMI COMMA }]
}
transition on SEMI to state [21]
transition on COMMA to state [20]

-------------------
lalr_state [20]: {
  [ConstDeclaration ::= (*) IDENT ASSIGN ConstType , {SEMI COMMA }]
  [ConstList ::= ConstList COMMA (*) ConstDeclaration , {SEMI COMMA }]
}
transition on IDENT to state [18]
transition on ConstDeclaration to state [22]

-------------------
lalr_state [21]: {
  [ConstDeclStart ::= CONST Type ConstList SEMI (*) , {LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [22]: {
  [ConstList ::= ConstList COMMA ConstDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [23]: {
  [ConstDeclaration ::= IDENT ASSIGN (*) ConstType , {SEMI COMMA }]
  [ConstType ::= (*) BOOL , {SEMI COMMA }]
  [ConstType ::= (*) CHAR , {SEMI COMMA }]
  [ConstType ::= (*) NUMBER , {SEMI COMMA }]
}
transition on CHAR to state [27]
transition on BOOL to state [26]
transition on ConstType to state [25]
transition on NUMBER to state [24]

-------------------
lalr_state [24]: {
  [ConstType ::= NUMBER (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [25]: {
  [ConstDeclaration ::= IDENT ASSIGN ConstType (*) , {SEMI COMMA }]
}

-------------------
lalr_state [26]: {
  [ConstType ::= BOOL (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [27]: {
  [ConstType ::= CHAR (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [28]: {
  [ClassName ::= CLASS IDENT (*) , {LBRACE EXT }]
}

-------------------
lalr_state [29]: {
  [ProgVarDeclStart ::= ProgVarType ProgVarList (*) SEMI , {LBRACE CONST IDENT CLASS }]
  [ProgVarList ::= ProgVarList (*) COMMA ProgVarDeclaration , {SEMI COMMA }]
}
transition on SEMI to state [36]
transition on COMMA to state [35]

-------------------
lalr_state [30]: {
  [ProgVarDeclaration ::= VarName (*) , {SEMI COMMA }]
}

-------------------
lalr_state [31]: {
  [VarName ::= IDENT (*) LBRACKET RBRACKET , {SEMI COMMA }]
  [VarName ::= IDENT (*) , {SEMI COMMA }]
}
transition on LBRACKET to state [33]

-------------------
lalr_state [32]: {
  [ProgVarList ::= ProgVarDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [33]: {
  [VarName ::= IDENT LBRACKET (*) RBRACKET , {SEMI COMMA }]
}
transition on RBRACKET to state [34]

-------------------
lalr_state [34]: {
  [VarName ::= IDENT LBRACKET RBRACKET (*) , {SEMI COMMA }]
}

-------------------
lalr_state [35]: {
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [ProgVarList ::= ProgVarList COMMA (*) ProgVarDeclaration , {SEMI COMMA }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
  [ProgVarDeclaration ::= (*) VarName , {SEMI COMMA }]
}
transition on IDENT to state [31]
transition on ProgVarDeclaration to state [37]
transition on VarName to state [30]

-------------------
lalr_state [36]: {
  [ProgVarDeclStart ::= ProgVarType ProgVarList SEMI (*) , {LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [37]: {
  [ProgVarList ::= ProgVarList COMMA ProgVarDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [38]: {
  [SuperClass ::= (*) IDENT , {LBRACE }]
  [SuperClass ::= (*) error , {LBRACE }]
  [OptionalClassExtends ::= EXT (*) SuperClass , {LBRACE }]
}
transition on IDENT to state [206]
transition on error to state [205]
transition on SuperClass to state [204]

-------------------
lalr_state [39]: {
  [ProgClassDecl ::= ClassName OptionalClassExtends (*) LBRACE VarDeclList ClassMethodDecl RBRACE , {LBRACE CONST IDENT CLASS }]
}
transition on LBRACE to state [40]

-------------------
lalr_state [40]: {
  [VarDeclList ::= (*) VarDeclList VarDeclStart , {LBRACE IDENT }]
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE (*) VarDeclList ClassMethodDecl RBRACE , {LBRACE CONST IDENT CLASS }]
  [VarDeclList ::= (*) , {LBRACE IDENT }]
}
transition on VarDeclList to state [41]

-------------------
lalr_state [41]: {
  [Type ::= (*) IDENT , {IDENT }]
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE VarDeclList (*) ClassMethodDecl RBRACE , {LBRACE CONST IDENT CLASS }]
  [ClassMethodDecl ::= (*) LBRACE MethodDeclList RBRACE , {RBRACE }]
  [VarDeclStart ::= (*) Type VarList SEMI , {LBRACE IDENT }]
  [VarDeclList ::= VarDeclList (*) VarDeclStart , {LBRACE IDENT }]
}
transition on IDENT to state [8]
transition on VarDeclStart to state [45]
transition on ClassMethodDecl to state [44]
transition on Type to state [43]
transition on LBRACE to state [42]

-------------------
lalr_state [42]: {
  [ClassMethodDecl ::= LBRACE (*) MethodDeclList RBRACE , {RBRACE }]
  [MethodDeclList ::= (*) , {RBRACE VOID IDENT }]
  [MethodDeclList ::= (*) MethodDeclList MethodDecl , {RBRACE VOID IDENT }]
}
transition on MethodDeclList to state [52]

-------------------
lalr_state [43]: {
  [VarList ::= (*) VarName , {SEMI COMMA }]
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [VarList ::= (*) VarList COMMA VarName , {SEMI COMMA }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
  [VarDeclStart ::= Type (*) VarList SEMI , {LBRACE IDENT }]
}
transition on VarList to state [48]
transition on IDENT to state [31]
transition on VarName to state [47]

-------------------
lalr_state [44]: {
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE VarDeclList ClassMethodDecl (*) RBRACE , {LBRACE CONST IDENT CLASS }]
}
transition on RBRACE to state [46]

-------------------
lalr_state [45]: {
  [VarDeclList ::= VarDeclList VarDeclStart (*) , {LBRACE IDENT }]
}

-------------------
lalr_state [46]: {
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE VarDeclList ClassMethodDecl RBRACE (*) , {LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [47]: {
  [VarList ::= VarName (*) , {SEMI COMMA }]
}

-------------------
lalr_state [48]: {
  [VarList ::= VarList (*) COMMA VarName , {SEMI COMMA }]
  [VarDeclStart ::= Type VarList (*) SEMI , {LBRACE IDENT }]
}
transition on SEMI to state [50]
transition on COMMA to state [49]

-------------------
lalr_state [49]: {
  [VarList ::= VarList COMMA (*) VarName , {SEMI COMMA }]
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
}
transition on IDENT to state [31]
transition on VarName to state [51]

-------------------
lalr_state [50]: {
  [VarDeclStart ::= Type VarList SEMI (*) , {LBRACE IDENT }]
}

-------------------
lalr_state [51]: {
  [VarList ::= VarList COMMA VarName (*) , {SEMI COMMA }]
}

-------------------
lalr_state [52]: {
  [Type ::= (*) IDENT , {IDENT }]
  [ClassMethodDecl ::= LBRACE MethodDeclList (*) RBRACE , {RBRACE }]
  [MethodDecl ::= (*) MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE , {RBRACE VOID IDENT }]
  [MethodTypeAndName ::= (*) VOID IDENT , {LPAREN }]
  [MethodTypeAndName ::= (*) Type IDENT , {LPAREN }]
  [MethodDeclList ::= MethodDeclList (*) MethodDecl , {RBRACE VOID IDENT }]
}
transition on VOID to state [57]
transition on MethodTypeAndName to state [56]
transition on IDENT to state [8]
transition on MethodDecl to state [55]
transition on RBRACE to state [54]
transition on Type to state [53]

-------------------
lalr_state [53]: {
  [MethodTypeAndName ::= Type (*) IDENT , {LPAREN }]
}
transition on IDENT to state [203]

-------------------
lalr_state [54]: {
  [ClassMethodDecl ::= LBRACE MethodDeclList RBRACE (*) , {RBRACE }]
}

-------------------
lalr_state [55]: {
  [MethodDeclList ::= MethodDeclList MethodDecl (*) , {RBRACE VOID IDENT }]
}

-------------------
lalr_state [56]: {
  [MethodDecl ::= MethodTypeAndName (*) LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE , {RBRACE VOID IDENT }]
}
transition on LPAREN to state [59]

-------------------
lalr_state [57]: {
  [MethodTypeAndName ::= VOID (*) IDENT , {LPAREN }]
}
transition on IDENT to state [58]

-------------------
lalr_state [58]: {
  [MethodTypeAndName ::= VOID IDENT (*) , {LPAREN }]
}

-------------------
lalr_state [59]: {
  [FormalParamDecl ::= (*) Type IDENT LBRACKET RBRACKET , {RPAREN COMMA }]
  [FormalParamList ::= (*) FormalParamList COMMA FormalParamDecl , {RPAREN COMMA }]
  [FormalParamDecl ::= (*) Type IDENT , {RPAREN COMMA }]
  [FormalParams ::= (*) , {RPAREN }]
  [Type ::= (*) IDENT , {IDENT }]
  [FormalParamDecl ::= (*) error , {RPAREN COMMA }]
  [MethodDecl ::= MethodTypeAndName LPAREN (*) FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE , {RBRACE VOID IDENT }]
  [FormalParamList ::= (*) FormalParamDecl , {RPAREN COMMA }]
  [FormalParams ::= (*) FormalParamList , {RPAREN }]
}
transition on FormalParamDecl to state [64]
transition on IDENT to state [8]
transition on FormalParams to state [63]
transition on FormalParamList to state [62]
transition on error to state [61]
transition on Type to state [60]

-------------------
lalr_state [60]: {
  [FormalParamDecl ::= Type (*) IDENT LBRACKET RBRACKET , {RPAREN COMMA }]
  [FormalParamDecl ::= Type (*) IDENT , {RPAREN COMMA }]
}
transition on IDENT to state [200]

-------------------
lalr_state [61]: {
  [FormalParamDecl ::= error (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [62]: {
  [FormalParams ::= FormalParamList (*) , {RPAREN }]
  [FormalParamList ::= FormalParamList (*) COMMA FormalParamDecl , {RPAREN COMMA }]
}
transition on COMMA to state [198]

-------------------
lalr_state [63]: {
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams (*) RPAREN VarDeclList LBRACE StatementList RBRACE , {RBRACE VOID IDENT }]
}
transition on RPAREN to state [65]

-------------------
lalr_state [64]: {
  [FormalParamList ::= FormalParamDecl (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [65]: {
  [VarDeclList ::= (*) VarDeclList VarDeclStart , {LBRACE IDENT }]
  [VarDeclList ::= (*) , {LBRACE IDENT }]
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN (*) VarDeclList LBRACE StatementList RBRACE , {RBRACE VOID IDENT }]
}
transition on VarDeclList to state [66]

-------------------
lalr_state [66]: {
  [Type ::= (*) IDENT , {IDENT }]
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList (*) LBRACE StatementList RBRACE , {RBRACE VOID IDENT }]
  [VarDeclStart ::= (*) Type VarList SEMI , {LBRACE IDENT }]
  [VarDeclList ::= VarDeclList (*) VarDeclStart , {LBRACE IDENT }]
}
transition on IDENT to state [8]
transition on VarDeclStart to state [45]
transition on Type to state [43]
transition on LBRACE to state [67]

-------------------
lalr_state [67]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE (*) StatementList RBRACE , {RBRACE VOID IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ELSE Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [StatementList ::= (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
  [StatementList ::= (*) StatementList Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on StatementList to state [88]
transition on ForeachConstruct to state [87]
transition on Statement to state [86]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [68]: {
  [FunctionName ::= Designator (*) , {LPAREN }]
  [DesignatorStatement ::= Designator (*) INC , {SEMI }]
  [ForeachDesignator ::= Designator (*) , {DOT }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= Designator (*) AssignmentStatementExpr , {SEMI }]
  [AssignmentStatementExpr ::= (*) ASSIGN Expr , {SEMI }]
  [Designator ::= Designator (*) DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= Designator (*) DEC , {SEMI }]
}
transition on ASSIGN to state [196]
transition on DOT to state [113]
transition on LBRACKET to state [112]
transition on DEC to state [195]
transition on INC to state [194]
transition on AssignmentStatementExpr to state [193]

-------------------
lalr_state [69]: {
  [Statement ::= READ (*) LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [189]

-------------------
lalr_state [70]: {
  [Statement ::= CONTINUE (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [188]

-------------------
lalr_state [71]: {
  [Designator ::= IDENT (*) , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [72]: {
  [Statement ::= DesignatorStatement (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [187]

-------------------
lalr_state [73]: {
  [ControlCondition ::= (*) LPAREN Condition RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= WHILE (*) ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [161]
transition on ControlCondition to state [185]

-------------------
lalr_state [74]: {
  [Statement ::= IfConstruct (*) ELSE Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= IfConstruct (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on ELSE to state [183]

-------------------
lalr_state [75]: {
  [Expr ::= (*) Term , {SEMI PLUS MINUS }]
  [Statement ::= RETURN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) ConstType , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Statement ::= RETURN (*) Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Term ::= (*) Term Mulop Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) Designator , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {SEMI PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on SEMI to state [181]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on BOOL to state [26]
transition on Expr to state [180]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [76]: {
  [IfConstruct ::= IF (*) ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ControlCondition ::= (*) LPAREN Condition RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [161]
transition on ControlCondition to state [160]

-------------------
lalr_state [77]: {
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorListContent ::= (*) DesignatorDummy , {RBRACKET COMMA }]
  [DesignatorListContent ::= (*) DesignatorListContent COMMA Designator , {RBRACKET COMMA }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorListStart ::= LBRACKET (*) DesignatorListContent RBRACKET , {ASSIGN }]
  [DesignatorListContent ::= (*) Designator , {RBRACKET COMMA }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorDummy ::= (*) , {RBRACKET COMMA }]
  [DesignatorListContent ::= (*) DesignatorListContent COMMA , {RBRACKET COMMA }]
}
transition on IDENT to state [71]
transition on DesignatorListContent to state [156]
transition on Designator to state [155]
transition on DesignatorDummy to state [154]

-------------------
lalr_state [78]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [OptionalStatementList ::= (*) StatementList , {RBRACE }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ELSE Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [StatementList ::= (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [OptionalStatementList ::= (*) , {RBRACE }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= LBRACE (*) OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
  [StatementList ::= (*) StatementList Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on StatementList to state [152]
transition on ForeachConstruct to state [87]
transition on OptionalStatementList to state [151]
transition on Statement to state [86]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [79]: {
  [ForeachConstruct ::= ForeachDesignator (*) DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on DOT to state [143]

-------------------
lalr_state [80]: {
  [Statement ::= WhileConstruct (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [81]: {
  [DesignatorStatement ::= FunctionCall (*) , {SEMI }]
}

-------------------
lalr_state [82]: {
  [FunctionCall ::= FunctionName (*) LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on LPAREN to state [140]

-------------------
lalr_state [83]: {
  [Statement ::= BREAK (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [139]

-------------------
lalr_state [84]: {
  [AssignmentStatementDesignator ::= (*) ASSIGN Designator , {SEMI }]
  [DesignatorStatement ::= DesignatorListStart (*) AssignmentStatementDesignator , {SEMI }]
}
transition on ASSIGN to state [137]
transition on AssignmentStatementDesignator to state [136]

-------------------
lalr_state [85]: {
  [Statement ::= PRINT (*) LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= PRINT (*) LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [91]

-------------------
lalr_state [86]: {
  [StatementList ::= Statement (*) , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [87]: {
  [Statement ::= ForeachConstruct (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [88]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ELSE Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
  [StatementList ::= StatementList (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList (*) RBRACE , {RBRACE VOID IDENT }]
}
transition on ForeachConstruct to state [87]
transition on Statement to state [90]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on RBRACE to state [89]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [89]: {
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE (*) , {RBRACE VOID IDENT }]
}

-------------------
lalr_state [90]: {
  [StatementList ::= StatementList Statement (*) , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [91]: {
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Statement ::= PRINT LPAREN (*) Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Statement ::= PRINT LPAREN (*) Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [93]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [92]: {
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) NUMBER , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= MINUS (*) Term , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [135]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on BOOL to state [26]
transition on IDENT to state [71]

-------------------
lalr_state [93]: {
  [Expr ::= Expr (*) Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Statement ::= PRINT LPAREN Expr (*) COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Statement ::= PRINT LPAREN Expr (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on PLUS to state [103]
transition on RPAREN to state [130]
transition on COMMA to state [129]

-------------------
lalr_state [94]: {
  [Type ::= (*) IDENT , {LBRACKET LPAREN }]
  [Factor ::= NEW (*) Type LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= NEW (*) Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on IDENT to state [8]
transition on Type to state [117]

-------------------
lalr_state [95]: {
  [Factor ::= FunctionCall (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [96]: {
  [FunctionName ::= Designator (*) , {LPAREN }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= Designator (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on DOT to state [113]
transition on LBRACKET to state [112]

-------------------
lalr_state [97]: {
  [Mulop ::= (*) MOD , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Mulop ::= (*) DIV , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Term ::= Term (*) Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Mulop ::= (*) MUL , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Term (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
}
transition on Mulop to state [110]
transition on DIV to state [109]
transition on MUL to state [108]
transition on MOD to state [107]

-------------------
lalr_state [98]: {
  [Term ::= Factor (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [99]: {
  [Expr ::= (*) Term , {RPAREN PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS }]
  [Factor ::= LPAREN (*) Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [101]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [100]: {
  [Factor ::= ConstType (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [101]: {
  [Expr ::= Expr (*) Addop Term , {RPAREN PLUS MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Factor ::= LPAREN Expr (*) RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on PLUS to state [103]
transition on RPAREN to state [102]

-------------------
lalr_state [102]: {
  [Factor ::= LPAREN Expr RPAREN (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [103]: {
  [Addop ::= PLUS (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [104]: {
  [Addop ::= MINUS (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [105]: {
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) NUMBER , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= Expr Addop (*) Term , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [106]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on BOOL to state [26]
transition on IDENT to state [71]

-------------------
lalr_state [106]: {
  [Mulop ::= (*) MOD , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Expr Addop Term (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Mulop ::= (*) DIV , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Term ::= Term (*) Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Mulop ::= (*) MUL , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Mulop to state [110]
transition on DIV to state [109]
transition on MUL to state [108]
transition on MOD to state [107]

-------------------
lalr_state [107]: {
  [Mulop ::= MOD (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [108]: {
  [Mulop ::= MUL (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [109]: {
  [Mulop ::= DIV (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [110]: {
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= Term Mulop (*) Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) NUMBER , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [111]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on BOOL to state [26]
transition on IDENT to state [71]

-------------------
lalr_state [111]: {
  [Term ::= Term Mulop Factor (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [112]: {
  [Expr ::= (*) Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= Designator LBRACKET (*) Expr RBRACKET , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) ConstType , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) Designator , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [115]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [113]: {
  [Designator ::= Designator DOT (*) IDENT , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on IDENT to state [114]

-------------------
lalr_state [114]: {
  [Designator ::= Designator DOT IDENT (*) , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [115]: {
  [Designator ::= Designator LBRACKET Expr (*) RBRACKET , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= Expr (*) Addop Term , {RBRACKET PLUS MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on RBRACKET to state [116]
transition on PLUS to state [103]

-------------------
lalr_state [116]: {
  [Designator ::= Designator LBRACKET Expr RBRACKET (*) , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [117]: {
  [Factor ::= NEW Type (*) LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= NEW Type (*) LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on LBRACKET to state [119]
transition on LPAREN to state [118]

-------------------
lalr_state [118]: {
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) , {RPAREN }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [ActualParam ::= (*) Expr , {RPAREN COMMA }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= (*) ActualParamList COMMA ActualParam , {RPAREN COMMA }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) ActualParamList , {RPAREN }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= NEW Type LPAREN (*) OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ActualParamList ::= (*) ActualParam , {RPAREN COMMA }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on OptionalMethodActualParams to state [125]
transition on ActualParamList to state [124]
transition on Factor to state [98]
transition on Term to state [97]
transition on ActualParam to state [123]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [122]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [119]: {
  [Expr ::= (*) Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) ConstType , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Factor ::= NEW Type LBRACKET (*) Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) Designator , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [120]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [120]: {
  [Expr ::= Expr (*) Addop Term , {RBRACKET PLUS MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Factor ::= NEW Type LBRACKET Expr (*) RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on RBRACKET to state [121]
transition on PLUS to state [103]

-------------------
lalr_state [121]: {
  [Factor ::= NEW Type LBRACKET Expr RBRACKET (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [122]: {
  [Expr ::= Expr (*) Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [ActualParam ::= Expr (*) , {RPAREN COMMA }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on PLUS to state [103]

-------------------
lalr_state [123]: {
  [ActualParamList ::= ActualParam (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [124]: {
  [ActualParamList ::= ActualParamList (*) COMMA ActualParam , {RPAREN COMMA }]
  [OptionalMethodActualParams ::= ActualParamList (*) , {RPAREN }]
}
transition on COMMA to state [127]

-------------------
lalr_state [125]: {
  [Factor ::= NEW Type LPAREN OptionalMethodActualParams (*) RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on RPAREN to state [126]

-------------------
lalr_state [126]: {
  [Factor ::= NEW Type LPAREN OptionalMethodActualParams RPAREN (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [127]: {
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [ActualParam ::= (*) Expr , {RPAREN COMMA }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= ActualParamList COMMA (*) ActualParam , {RPAREN COMMA }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on ActualParam to state [128]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [122]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [128]: {
  [ActualParamList ::= ActualParamList COMMA ActualParam (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [129]: {
  [Statement ::= PRINT LPAREN Expr COMMA (*) NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on NUMBER to state [132]

-------------------
lalr_state [130]: {
  [Statement ::= PRINT LPAREN Expr RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [131]

-------------------
lalr_state [131]: {
  [Statement ::= PRINT LPAREN Expr RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [132]: {
  [Statement ::= PRINT LPAREN Expr COMMA NUMBER (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on RPAREN to state [133]

-------------------
lalr_state [133]: {
  [Statement ::= PRINT LPAREN Expr COMMA NUMBER RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [134]

-------------------
lalr_state [134]: {
  [Statement ::= PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [135]: {
  [Mulop ::= (*) MOD , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Mulop ::= (*) DIV , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Term ::= Term (*) Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= MINUS Term (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Mulop ::= (*) MUL , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Mulop to state [110]
transition on DIV to state [109]
transition on MUL to state [108]
transition on MOD to state [107]

-------------------
lalr_state [136]: {
  [DesignatorStatement ::= DesignatorListStart AssignmentStatementDesignator (*) , {SEMI }]
}

-------------------
lalr_state [137]: {
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET SEMI DOT }]
  [Designator ::= (*) IDENT , {LBRACKET SEMI DOT }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET SEMI DOT }]
  [AssignmentStatementDesignator ::= ASSIGN (*) Designator , {SEMI }]
}
transition on Designator to state [138]
transition on IDENT to state [71]

-------------------
lalr_state [138]: {
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET SEMI DOT }]
  [AssignmentStatementDesignator ::= ASSIGN Designator (*) , {SEMI }]
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET SEMI DOT }]
}
transition on DOT to state [113]
transition on LBRACKET to state [112]

-------------------
lalr_state [139]: {
  [Statement ::= BREAK SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [140]: {
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) , {RPAREN }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [ActualParam ::= (*) Expr , {RPAREN COMMA }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= (*) ActualParamList COMMA ActualParam , {RPAREN COMMA }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) ActualParamList , {RPAREN }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= FunctionName LPAREN (*) OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= (*) ActualParam , {RPAREN COMMA }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on OptionalMethodActualParams to state [141]
transition on ActualParamList to state [124]
transition on Factor to state [98]
transition on Term to state [97]
transition on ActualParam to state [123]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [122]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [141]: {
  [FunctionCall ::= FunctionName LPAREN OptionalMethodActualParams (*) RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on RPAREN to state [142]

-------------------
lalr_state [142]: {
  [FunctionCall ::= FunctionName LPAREN OptionalMethodActualParams RPAREN (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [143]: {
  [ForeachConstruct ::= ForeachDesignator DOT (*) FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on FOREACH to state [144]

-------------------
lalr_state [144]: {
  [ForeachConstruct ::= ForeachDesignator DOT FOREACH (*) LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [145]

-------------------
lalr_state [145]: {
  [ForeachConstruct ::= ForeachDesignator DOT FOREACH LPAREN (*) IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on IDENT to state [146]

-------------------
lalr_state [146]: {
  [ForeachConstruct ::= ForeachDesignator DOT FOREACH LPAREN IDENT (*) ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on ARROW to state [147]

-------------------
lalr_state [147]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {RPAREN }]
  [Statement ::= (*) RETURN SEMI , {RPAREN }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {RPAREN ELSE }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {RPAREN }]
  [Statement ::= (*) BREAK SEMI , {RPAREN }]
  [Statement ::= (*) IfConstruct ELSE Statement , {RPAREN }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {RPAREN }]
  [Statement ::= (*) RETURN Expr SEMI , {RPAREN }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {RPAREN }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {RPAREN }]
  [Statement ::= (*) CONTINUE SEMI , {RPAREN }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {RPAREN }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [ForeachConstruct ::= ForeachDesignator DOT FOREACH LPAREN IDENT ARROW (*) Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {RPAREN }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {RPAREN }]
  [Statement ::= (*) IfConstruct , {RPAREN }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {RPAREN }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
}
transition on ForeachConstruct to state [87]
transition on Statement to state [148]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [148]: {
  [ForeachConstruct ::= ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on RPAREN to state [149]

-------------------
lalr_state [149]: {
  [ForeachConstruct ::= ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [150]

-------------------
lalr_state [150]: {
  [ForeachConstruct ::= ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [151]: {
  [Statement ::= LBRACE OptionalStatementList (*) RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on RBRACE to state [153]

-------------------
lalr_state [152]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [OptionalStatementList ::= StatementList (*) , {RBRACE }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ELSE Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
  [StatementList ::= StatementList (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on ForeachConstruct to state [87]
transition on Statement to state [90]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [153]: {
  [Statement ::= LBRACE OptionalStatementList RBRACE (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [154]: {
  [DesignatorListContent ::= DesignatorDummy (*) , {RBRACKET COMMA }]
}

-------------------
lalr_state [155]: {
  [DesignatorListContent ::= Designator (*) , {RBRACKET COMMA }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET RBRACKET COMMA DOT }]
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET RBRACKET COMMA DOT }]
}
transition on DOT to state [113]
transition on LBRACKET to state [112]

-------------------
lalr_state [156]: {
  [DesignatorListStart ::= LBRACKET DesignatorListContent (*) RBRACKET , {ASSIGN }]
  [DesignatorListContent ::= DesignatorListContent (*) COMMA , {RBRACKET COMMA }]
  [DesignatorListContent ::= DesignatorListContent (*) COMMA Designator , {RBRACKET COMMA }]
}
transition on RBRACKET to state [158]
transition on COMMA to state [157]

-------------------
lalr_state [157]: {
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorListContent ::= DesignatorListContent COMMA (*) , {RBRACKET COMMA }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorListContent ::= DesignatorListContent COMMA (*) Designator , {RBRACKET COMMA }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET COMMA DOT }]
}
transition on Designator to state [159]
transition on IDENT to state [71]

-------------------
lalr_state [158]: {
  [DesignatorListStart ::= LBRACKET DesignatorListContent RBRACKET (*) , {ASSIGN }]
}

-------------------
lalr_state [159]: {
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorListContent ::= DesignatorListContent COMMA Designator (*) , {RBRACKET COMMA }]
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET RBRACKET COMMA DOT }]
}
transition on DOT to state [113]
transition on LBRACKET to state [112]

-------------------
lalr_state [160]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= IF ControlCondition (*) Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ELSE Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
}
transition on ForeachConstruct to state [87]
transition on Statement to state [179]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [161]: {
  [Expr ::= (*) Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Condition ::= (*) Condition OR ConditionTerm , {RPAREN OR }]
  [ConditionFactor ::= (*) Expr , {RPAREN OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionFactor , {RPAREN OR AND }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Condition ::= (*) ConditionTerm , {RPAREN OR }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ControlCondition ::= LPAREN (*) Condition RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ConditionFactor ::= (*) Expr Relop Expr , {RPAREN OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionTerm AND ConditionFactor , {RPAREN OR AND }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on Condition to state [165]
transition on ConditionFactor to state [164]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [163]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]
transition on ConditionTerm to state [162]

-------------------
lalr_state [162]: {
  [Condition ::= ConditionTerm (*) , {RPAREN OR }]
  [ConditionTerm ::= ConditionTerm (*) AND ConditionFactor , {RPAREN OR AND }]
}
transition on AND to state [169]

-------------------
lalr_state [163]: {
  [Relop ::= (*) GT , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [ConditionFactor ::= Expr (*) Relop Expr , {RPAREN OR AND }]
  [Relop ::= (*) GE , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Relop ::= (*) NE , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Relop ::= (*) LT , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Relop ::= (*) EQ , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Expr ::= Expr (*) Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [ConditionFactor ::= Expr (*) , {RPAREN OR AND }]
  [Relop ::= (*) LE , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}
transition on LT to state [177]
transition on NE to state [176]
transition on GT to state [175]
transition on LE to state [174]
transition on Relop to state [173]
transition on Addop to state [105]
transition on EQ to state [172]
transition on PLUS to state [103]
transition on GE to state [171]
transition on MINUS to state [104]

-------------------
lalr_state [164]: {
  [ConditionTerm ::= ConditionFactor (*) , {RPAREN OR AND }]
}

-------------------
lalr_state [165]: {
  [Condition ::= Condition (*) OR ConditionTerm , {RPAREN OR }]
  [ControlCondition ::= LPAREN Condition (*) RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on OR to state [167]
transition on RPAREN to state [166]

-------------------
lalr_state [166]: {
  [ControlCondition ::= LPAREN Condition RPAREN (*) , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [167]: {
  [Expr ::= (*) Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Condition ::= Condition OR (*) ConditionTerm , {RPAREN OR }]
  [ConditionFactor ::= (*) Expr , {RPAREN OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionFactor , {RPAREN OR AND }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionFactor ::= (*) Expr Relop Expr , {RPAREN OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionTerm AND ConditionFactor , {RPAREN OR AND }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on ConditionFactor to state [164]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [163]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on ConditionTerm to state [168]
transition on MINUS to state [92]

-------------------
lalr_state [168]: {
  [Condition ::= Condition OR ConditionTerm (*) , {RPAREN OR }]
  [ConditionTerm ::= ConditionTerm (*) AND ConditionFactor , {RPAREN OR AND }]
}
transition on AND to state [169]

-------------------
lalr_state [169]: {
  [Expr ::= (*) Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionFactor ::= (*) Expr , {RPAREN OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionFactor ::= (*) Expr Relop Expr , {RPAREN OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= ConditionTerm AND (*) ConditionFactor , {RPAREN OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on ConditionFactor to state [170]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on Expr to state [163]
transition on BOOL to state [26]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [170]: {
  [ConditionTerm ::= ConditionTerm AND ConditionFactor (*) , {RPAREN OR AND }]
}

-------------------
lalr_state [171]: {
  [Relop ::= GE (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [172]: {
  [Relop ::= EQ (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [173]: {
  [Expr ::= (*) Term , {RPAREN PLUS MINUS OR AND }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS OR AND }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ConditionFactor ::= Expr Relop (*) Expr , {RPAREN OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on BOOL to state [26]
transition on Expr to state [178]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [174]: {
  [Relop ::= LE (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [175]: {
  [Relop ::= GT (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [176]: {
  [Relop ::= NE (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [177]: {
  [Relop ::= LT (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [178]: {
  [Expr ::= Expr (*) Addop Term , {RPAREN PLUS MINUS OR AND }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [ConditionFactor ::= Expr Relop Expr (*) , {RPAREN OR AND }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on PLUS to state [103]

-------------------
lalr_state [179]: {
  [IfConstruct ::= IF ControlCondition Statement (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [180]: {
  [Expr ::= Expr (*) Addop Term , {SEMI PLUS MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Statement ::= RETURN Expr (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on SEMI to state [182]
transition on PLUS to state [103]

-------------------
lalr_state [181]: {
  [Statement ::= RETURN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [182]: {
  [Statement ::= RETURN Expr SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [183]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= IfConstruct ELSE (*) Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ELSE Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
}
transition on ForeachConstruct to state [87]
transition on Statement to state [184]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [184]: {
  [Statement ::= IfConstruct ELSE Statement (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [185]: {
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IF ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ELSE Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator , {DOT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [WhileConstruct ::= WHILE ControlCondition (*) Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WHILE ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator AssignmentStatementExpr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart AssignmentStatementDesignator , {SEMI }]
  [DesignatorListStart ::= (*) LBRACKET DesignatorListContent RBRACKET , {ASSIGN }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI }]
}
transition on ForeachConstruct to state [87]
transition on Statement to state [186]
transition on PRINT to state [85]
transition on DesignatorListStart to state [84]
transition on BREAK to state [83]
transition on FunctionName to state [82]
transition on FunctionCall to state [81]
transition on WhileConstruct to state [80]
transition on ForeachDesignator to state [79]
transition on LBRACE to state [78]
transition on LBRACKET to state [77]
transition on IF to state [76]
transition on RETURN to state [75]
transition on IfConstruct to state [74]
transition on WHILE to state [73]
transition on DesignatorStatement to state [72]
transition on IDENT to state [71]
transition on CONTINUE to state [70]
transition on READ to state [69]
transition on Designator to state [68]

-------------------
lalr_state [186]: {
  [WhileConstruct ::= WHILE ControlCondition Statement (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [187]: {
  [Statement ::= DesignatorStatement SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [188]: {
  [Statement ::= CONTINUE SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [189]: {
  [Statement ::= READ LPAREN (*) Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RPAREN DOT }]
  [Designator ::= (*) IDENT , {LBRACKET RPAREN DOT }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RPAREN DOT }]
}
transition on Designator to state [190]
transition on IDENT to state [71]

-------------------
lalr_state [190]: {
  [Statement ::= READ LPAREN Designator (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET RPAREN DOT }]
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET RPAREN DOT }]
}
transition on DOT to state [113]
transition on LBRACKET to state [112]
transition on RPAREN to state [191]

-------------------
lalr_state [191]: {
  [Statement ::= READ LPAREN Designator RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [192]

-------------------
lalr_state [192]: {
  [Statement ::= READ LPAREN Designator RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [193]: {
  [DesignatorStatement ::= Designator AssignmentStatementExpr (*) , {SEMI }]
}

-------------------
lalr_state [194]: {
  [DesignatorStatement ::= Designator INC (*) , {SEMI }]
}

-------------------
lalr_state [195]: {
  [DesignatorStatement ::= Designator DEC (*) , {SEMI }]
}

-------------------
lalr_state [196]: {
  [Expr ::= (*) Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) NEW Type LPAREN OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) ConstType , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [FunctionName ::= (*) Designator , {LPAREN }]
  [Term ::= (*) Term Mulop Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) NUMBER , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {SEMI PLUS MINUS MUL DIV MOD }]
  [AssignmentStatementExpr ::= ASSIGN (*) Expr , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) Designator , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {SEMI PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName LPAREN OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [27]
transition on ConstType to state [100]
transition on LPAREN to state [99]
transition on Factor to state [98]
transition on Term to state [97]
transition on NUMBER to state [24]
transition on FunctionName to state [82]
transition on Designator to state [96]
transition on FunctionCall to state [95]
transition on NEW to state [94]
transition on BOOL to state [26]
transition on Expr to state [197]
transition on IDENT to state [71]
transition on MINUS to state [92]

-------------------
lalr_state [197]: {
  [Expr ::= Expr (*) Addop Term , {SEMI PLUS MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [AssignmentStatementExpr ::= ASSIGN Expr (*) , {SEMI }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [105]
transition on MINUS to state [104]
transition on PLUS to state [103]

-------------------
lalr_state [198]: {
  [Type ::= (*) IDENT , {IDENT }]
  [FormalParamList ::= FormalParamList COMMA (*) FormalParamDecl , {RPAREN COMMA }]
  [FormalParamDecl ::= (*) Type IDENT LBRACKET RBRACKET , {RPAREN COMMA }]
  [FormalParamDecl ::= (*) Type IDENT , {RPAREN COMMA }]
  [FormalParamDecl ::= (*) error , {RPAREN COMMA }]
}
transition on FormalParamDecl to state [199]
transition on IDENT to state [8]
transition on error to state [61]
transition on Type to state [60]

-------------------
lalr_state [199]: {
  [FormalParamList ::= FormalParamList COMMA FormalParamDecl (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [200]: {
  [FormalParamDecl ::= Type IDENT (*) LBRACKET RBRACKET , {RPAREN COMMA }]
  [FormalParamDecl ::= Type IDENT (*) , {RPAREN COMMA }]
}
transition on LBRACKET to state [201]

-------------------
lalr_state [201]: {
  [FormalParamDecl ::= Type IDENT LBRACKET (*) RBRACKET , {RPAREN COMMA }]
}
transition on RBRACKET to state [202]

-------------------
lalr_state [202]: {
  [FormalParamDecl ::= Type IDENT LBRACKET RBRACKET (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [203]: {
  [MethodTypeAndName ::= Type IDENT (*) , {LPAREN }]
}

-------------------
lalr_state [204]: {
  [OptionalClassExtends ::= EXT SuperClass (*) , {LBRACE }]
}

-------------------
lalr_state [205]: {
  [SuperClass ::= error (*) , {LBRACE }]
}

-------------------
lalr_state [206]: {
  [SuperClass ::= IDENT (*) , {LBRACE }]
}

-------------------
lalr_state [207]: {
  [Type ::= (*) IDENT , {IDENT }]
  [MethodDecl ::= (*) MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE , {RBRACE VOID IDENT }]
  [MethodTypeAndName ::= (*) VOID IDENT , {LPAREN }]
  [Program ::= PROG ProgName ProgDeclList LBRACE MethodDeclList (*) RBRACE , {EOF }]
  [MethodTypeAndName ::= (*) Type IDENT , {LPAREN }]
  [MethodDeclList ::= MethodDeclList (*) MethodDecl , {RBRACE VOID IDENT }]
}
transition on VOID to state [57]
transition on MethodTypeAndName to state [56]
transition on IDENT to state [8]
transition on MethodDecl to state [55]
transition on RBRACE to state [208]
transition on Type to state [53]

-------------------
lalr_state [208]: {
  [Program ::= PROG ProgName ProgDeclList LBRACE MethodDeclList RBRACE (*) , {EOF }]
}

-------------------
lalr_state [209]: {
  [$START ::= Program EOF (*) , {EOF }]
}

-------------------
Closing files...
------- CUP v0.10k Parser Generation Summary -------
  1 error and 5 warnings
  48 terminals, 57 non-terminals, and 119 productions declared, 
  producing 210 unique parse states.
  1 terminal declared but not used.
  0 non-terminal declared but not used.
  0 productions never reduced.
  3 conflicts detected (0 expected).
  No code produced.
---------------------------------------------------- (v0.10k)
