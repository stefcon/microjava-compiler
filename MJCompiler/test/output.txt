Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "COLON" was declared but never used
------- ast extension v0.8 summary -------
  Generated 43 base classesBuilding parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...

  Generated 115 derived classes
  Generated 25 record classes
  Generated interface SyntaxNode
  Generated interface Visitor
  Generated adapter class VisitorAdaptor
  Filling in tables...-----------------------------------------------

  Checking for non-reduced productions...
Writing parser...
===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [$START ::= (*) Program EOF , {EOF }]
  [Program ::= (*) PROG ProgName ProgDeclList LBRACE OptionalMethodDeclList RBRACE , {EOF }]
}
transition on PROG to state [2]
transition on Program to state [1]

-------------------
lalr_state [1]: {
  [$START ::= Program (*) EOF , {EOF }]
}
transition on EOF to state [255]

-------------------
lalr_state [2]: {
  [ProgName ::= (*) IDENT , {error LBRACE CONST IDENT CLASS }]
  [Program ::= PROG (*) ProgName ProgDeclList LBRACE OptionalMethodDeclList RBRACE , {EOF }]
}
transition on ProgName to state [4]
transition on IDENT to state [3]

-------------------
lalr_state [3]: {
  [ProgName ::= IDENT (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [4]: {
  [ProgDeclList ::= (*) ProgDeclList ProgClassDecl , {error LBRACE CONST IDENT CLASS }]
  [ProgDeclList ::= (*) ProgDeclList ProgVarDeclStart , {error LBRACE CONST IDENT CLASS }]
  [ProgDeclList ::= (*) , {error LBRACE CONST IDENT CLASS }]
  [Program ::= PROG ProgName (*) ProgDeclList LBRACE OptionalMethodDeclList RBRACE , {EOF }]
  [ProgDeclList ::= (*) ProgDeclList ConstDeclStart , {error LBRACE CONST IDENT CLASS }]
}
transition on ProgDeclList to state [5]

-------------------
lalr_state [5]: {
  [ClassName ::= (*) CLASS IDENT , {error LBRACE EXT }]
  [ProgVarType ::= (*) Type , {IDENT }]
  [ProgDeclList ::= ProgDeclList (*) ProgClassDecl , {error LBRACE CONST IDENT CLASS }]
  [ProgVarDeclStart ::= (*) error NT$2 COMMA , {error LBRACE CONST IDENT CLASS }]
  [ProgClassDecl ::= (*) ClassName error VarDeclList OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
  [Type ::= (*) IDENT , {IDENT }]
  [ConstDeclStart ::= (*) CONST Type ConstList SEMI , {error LBRACE CONST IDENT CLASS }]
  [ProgVarDeclStart ::= (*) error NT$3 SEMI , {error LBRACE CONST IDENT CLASS }]
  [ProgDeclList ::= ProgDeclList (*) ProgVarDeclStart , {error LBRACE CONST IDENT CLASS }]
  [ProgClassDecl ::= (*) ClassName OptionalClassExtends LBRACE VarDeclList OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
  [Program ::= PROG ProgName ProgDeclList (*) LBRACE OptionalMethodDeclList RBRACE , {EOF }]
  [ProgDeclList ::= ProgDeclList (*) ConstDeclStart , {error LBRACE CONST IDENT CLASS }]
  [ProgVarDeclStart ::= (*) ProgVarType ProgVarList SEMI , {error LBRACE CONST IDENT CLASS }]
}
transition on CONST to state [16]
transition on CLASS to state [15]
transition on ProgVarType to state [14]
transition on ClassName to state [13]
transition on error to state [12]
transition on ProgVarDeclStart to state [11]
transition on ConstDeclStart to state [10]
transition on ProgClassDecl to state [9]
transition on IDENT to state [8]
transition on LBRACE to state [7]
transition on Type to state [6]

-------------------
lalr_state [6]: {
  [ProgVarType ::= Type (*) , {IDENT }]
}

-------------------
lalr_state [7]: {
  [MethodTypeAndName ::= (*) Type IDENT , {LPAREN }]
  [MethodDeclList ::= (*) MethodDeclList MethodDecl , {RBRACE VOID IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [MethodDecl ::= (*) MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [OptionalMethodDeclList ::= (*) , {RBRACE }]
  [Program ::= PROG ProgName ProgDeclList LBRACE (*) OptionalMethodDeclList RBRACE , {EOF }]
  [MethodTypeAndName ::= (*) VOID IDENT , {LPAREN }]
  [MethodDeclList ::= (*) MethodDecl , {RBRACE VOID IDENT }]
  [OptionalMethodDeclList ::= (*) MethodDeclList , {RBRACE }]
}
transition on VOID to state [67]
transition on MethodTypeAndName to state [65]
transition on IDENT to state [8]
transition on MethodDecl to state [66]
transition on MethodDeclList to state [69]
transition on Type to state [61]
transition on OptionalMethodDeclList to state [253]

-------------------
lalr_state [8]: {
  [Type ::= IDENT (*) , {LBRACKET LPAREN IDENT }]
}

-------------------
lalr_state [9]: {
  [ProgDeclList ::= ProgDeclList ProgClassDecl (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [10]: {
  [ProgDeclList ::= ProgDeclList ConstDeclStart (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [11]: {
  [ProgDeclList ::= ProgDeclList ProgVarDeclStart (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [12]: {
  [NT$2 ::= (*) , {COMMA }]
  [NT$3 ::= (*) , {SEMI }]
  [ProgVarDeclStart ::= error (*) NT$2 COMMA , {error LBRACE CONST IDENT CLASS }]
  [ProgVarDeclStart ::= error (*) NT$3 SEMI , {error LBRACE CONST IDENT CLASS }]
}
transition on NT$2 to state [250]
transition on NT$3 to state [249]

-------------------
lalr_state [13]: {
  [OptionalClassExtends ::= (*) EXT error NT$4 LBRACE , {LBRACE }]
  [OptionalClassExtends ::= (*) EXT SuperClass , {LBRACE }]
  [ProgClassDecl ::= ClassName (*) OptionalClassExtends LBRACE VarDeclList OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
  [OptionalClassExtends ::= (*) , {LBRACE }]
  [ProgClassDecl ::= ClassName (*) error VarDeclList OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
}
transition on OptionalClassExtends to state [41]
transition on error to state [40]
transition on EXT to state [39]

-------------------
lalr_state [14]: {
  [ProgVarList ::= (*) ProgVarList COMMA ProgVarDeclaration , {SEMI COMMA }]
  [ProgVarDeclStart ::= ProgVarType (*) ProgVarList SEMI , {error LBRACE CONST IDENT CLASS }]
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [ProgVarDeclaration ::= (*) VarName , {SEMI COMMA }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
  [ProgVarList ::= (*) ProgVarDeclaration , {SEMI COMMA }]
}
transition on IDENT to state [33]
transition on ProgVarDeclaration to state [32]
transition on VarName to state [31]
transition on ProgVarList to state [30]

-------------------
lalr_state [15]: {
  [ClassName ::= CLASS (*) IDENT , {error LBRACE EXT }]
}
transition on IDENT to state [29]

-------------------
lalr_state [16]: {
  [ConstDeclStart ::= CONST (*) Type ConstList SEMI , {error LBRACE CONST IDENT CLASS }]
  [Type ::= (*) IDENT , {IDENT }]
}
transition on IDENT to state [8]
transition on Type to state [17]

-------------------
lalr_state [17]: {
  [ConstList ::= (*) ConstList COMMA ConstDeclaration , {SEMI COMMA }]
  [ConstDeclStart ::= CONST Type (*) ConstList SEMI , {error LBRACE CONST IDENT CLASS }]
  [ConstDeclaration ::= (*) IDENT ASSIGN ConstType , {SEMI COMMA }]
  [ConstList ::= (*) ConstDeclaration , {SEMI COMMA }]
}
transition on ConstList to state [20]
transition on IDENT to state [19]
transition on ConstDeclaration to state [18]

-------------------
lalr_state [18]: {
  [ConstList ::= ConstDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [19]: {
  [ConstDeclaration ::= IDENT (*) ASSIGN ConstType , {SEMI COMMA }]
}
transition on ASSIGN to state [24]

-------------------
lalr_state [20]: {
  [ConstDeclStart ::= CONST Type ConstList (*) SEMI , {error LBRACE CONST IDENT CLASS }]
  [ConstList ::= ConstList (*) COMMA ConstDeclaration , {SEMI COMMA }]
}
transition on SEMI to state [22]
transition on COMMA to state [21]

-------------------
lalr_state [21]: {
  [ConstDeclaration ::= (*) IDENT ASSIGN ConstType , {SEMI COMMA }]
  [ConstList ::= ConstList COMMA (*) ConstDeclaration , {SEMI COMMA }]
}
transition on IDENT to state [19]
transition on ConstDeclaration to state [23]

-------------------
lalr_state [22]: {
  [ConstDeclStart ::= CONST Type ConstList SEMI (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [23]: {
  [ConstList ::= ConstList COMMA ConstDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [24]: {
  [ConstDeclaration ::= IDENT ASSIGN (*) ConstType , {SEMI COMMA }]
  [ConstType ::= (*) BOOL , {SEMI COMMA }]
  [ConstType ::= (*) CHAR , {SEMI COMMA }]
  [ConstType ::= (*) NUMBER , {SEMI COMMA }]
}
transition on CHAR to state [28]
transition on BOOL to state [27]
transition on ConstType to state [26]
transition on NUMBER to state [25]

-------------------
lalr_state [25]: {
  [ConstType ::= NUMBER (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [26]: {
  [ConstDeclaration ::= IDENT ASSIGN ConstType (*) , {SEMI COMMA }]
}

-------------------
lalr_state [27]: {
  [ConstType ::= BOOL (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [28]: {
  [ConstType ::= CHAR (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [29]: {
  [ClassName ::= CLASS IDENT (*) , {error LBRACE EXT }]
}

-------------------
lalr_state [30]: {
  [ProgVarList ::= ProgVarList (*) COMMA ProgVarDeclaration , {SEMI COMMA }]
  [ProgVarDeclStart ::= ProgVarType ProgVarList (*) SEMI , {error LBRACE CONST IDENT CLASS }]
}
transition on SEMI to state [37]
transition on COMMA to state [36]

-------------------
lalr_state [31]: {
  [ProgVarDeclaration ::= VarName (*) , {SEMI COMMA }]
}

-------------------
lalr_state [32]: {
  [ProgVarList ::= ProgVarDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [33]: {
  [VarName ::= IDENT (*) LBRACKET RBRACKET , {SEMI COMMA }]
  [VarName ::= IDENT (*) , {SEMI COMMA }]
}
transition on LBRACKET to state [34]

-------------------
lalr_state [34]: {
  [VarName ::= IDENT LBRACKET (*) RBRACKET , {SEMI COMMA }]
}
transition on RBRACKET to state [35]

-------------------
lalr_state [35]: {
  [VarName ::= IDENT LBRACKET RBRACKET (*) , {SEMI COMMA }]
}

-------------------
lalr_state [36]: {
  [ProgVarList ::= ProgVarList COMMA (*) ProgVarDeclaration , {SEMI COMMA }]
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [ProgVarDeclaration ::= (*) VarName , {SEMI COMMA }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
}
transition on ProgVarDeclaration to state [38]
transition on IDENT to state [33]
transition on VarName to state [31]

-------------------
lalr_state [37]: {
  [ProgVarDeclStart ::= ProgVarType ProgVarList SEMI (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [38]: {
  [ProgVarList ::= ProgVarList COMMA ProgVarDeclaration (*) , {SEMI COMMA }]
}

-------------------
lalr_state [39]: {
  [OptionalClassExtends ::= EXT (*) SuperClass , {LBRACE }]
  [SuperClass ::= (*) IDENT , {LBRACE }]
  [OptionalClassExtends ::= EXT (*) error NT$4 LBRACE , {LBRACE }]
}
transition on IDENT to state [246]
transition on error to state [245]
transition on SuperClass to state [244]

-------------------
lalr_state [40]: {
  [VarDeclList ::= (*) VarDeclList VarDeclStart , {error LBRACE RBRACE IDENT }]
  [ProgClassDecl ::= ClassName error (*) VarDeclList OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
  [VarDeclList ::= (*) , {error LBRACE RBRACE IDENT }]
}
transition on VarDeclList to state [241]

-------------------
lalr_state [41]: {
  [ProgClassDecl ::= ClassName OptionalClassExtends (*) LBRACE VarDeclList OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
}
transition on LBRACE to state [42]

-------------------
lalr_state [42]: {
  [VarDeclList ::= (*) VarDeclList VarDeclStart , {error LBRACE RBRACE IDENT }]
  [VarDeclList ::= (*) , {error LBRACE RBRACE IDENT }]
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE (*) VarDeclList OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
}
transition on VarDeclList to state [43]

-------------------
lalr_state [43]: {
  [OptionalClassMethodDecl ::= (*) LBRACE ConstructorDeclList OptionalMethodDeclList RBRACE , {RBRACE }]
  [VarDeclStart ::= (*) error SEMI , {error LBRACE RBRACE IDENT }]
  [VarDeclStart ::= (*) Type VarList SEMI , {error LBRACE RBRACE IDENT }]
  [VarDeclStart ::= (*) error NT$1 LBRACE , {error LBRACE RBRACE IDENT }]
  [VarDeclStart ::= (*) error NT$0 COMMA , {error LBRACE RBRACE IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [VarDeclList ::= VarDeclList (*) VarDeclStart , {error LBRACE RBRACE IDENT }]
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE VarDeclList (*) OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
  [OptionalClassMethodDecl ::= (*) , {RBRACE }]
}
transition on IDENT to state [8]
transition on OptionalClassMethodDecl to state [48]
transition on VarDeclStart to state [47]
transition on error to state [46]
transition on Type to state [45]
transition on LBRACE to state [44]

-------------------
lalr_state [44]: {
  [ConstructorDeclList ::= (*) , {RBRACE VOID IDENT }]
  [OptionalClassMethodDecl ::= LBRACE (*) ConstructorDeclList OptionalMethodDeclList RBRACE , {RBRACE }]
  [ConstructorDeclList ::= (*) ConstructorDeclList ConstructorDecl , {RBRACE VOID IDENT }]
}
transition on ConstructorDeclList to state [60]

-------------------
lalr_state [45]: {
  [VarList ::= (*) VarName , {SEMI COMMA }]
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [VarList ::= (*) VarList COMMA VarName , {SEMI COMMA }]
  [VarDeclStart ::= Type (*) VarList SEMI , {error LBRACE RBRACE IDENT }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
}
transition on VarList to state [56]
transition on IDENT to state [33]
transition on VarName to state [55]

-------------------
lalr_state [46]: {
  [VarDeclStart ::= error (*) NT$0 COMMA , {error LBRACE RBRACE IDENT }]
  [NT$1 ::= (*) , {LBRACE }]
  [NT$0 ::= (*) , {COMMA }]
  [VarDeclStart ::= error (*) SEMI , {error LBRACE RBRACE IDENT }]
  [VarDeclStart ::= error (*) NT$1 LBRACE , {error LBRACE RBRACE IDENT }]
}
transition on SEMI to state [52]
transition on NT$0 to state [51]
transition on NT$1 to state [50]

-------------------
lalr_state [47]: {
  [VarDeclList ::= VarDeclList VarDeclStart (*) , {error LBRACE RBRACE IDENT }]
}

-------------------
lalr_state [48]: {
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE VarDeclList OptionalClassMethodDecl (*) RBRACE , {error LBRACE CONST IDENT CLASS }]
}
transition on RBRACE to state [49]

-------------------
lalr_state [49]: {
  [ProgClassDecl ::= ClassName OptionalClassExtends LBRACE VarDeclList OptionalClassMethodDecl RBRACE (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [50]: {
  [VarDeclStart ::= error NT$1 (*) LBRACE , {error LBRACE RBRACE IDENT }]
}
transition on LBRACE to state [54]

-------------------
lalr_state [51]: {
  [VarDeclStart ::= error NT$0 (*) COMMA , {error LBRACE RBRACE IDENT }]
}
transition on COMMA to state [53]

-------------------
lalr_state [52]: {
  [VarDeclStart ::= error SEMI (*) , {error LBRACE RBRACE IDENT }]
}

-------------------
lalr_state [53]: {
  [VarDeclStart ::= error NT$0 COMMA (*) , {error LBRACE RBRACE IDENT }]
}

-------------------
lalr_state [54]: {
  [VarDeclStart ::= error NT$1 LBRACE (*) , {error LBRACE RBRACE IDENT }]
}

-------------------
lalr_state [55]: {
  [VarList ::= VarName (*) , {SEMI COMMA }]
}

-------------------
lalr_state [56]: {
  [VarList ::= VarList (*) COMMA VarName , {SEMI COMMA }]
  [VarDeclStart ::= Type VarList (*) SEMI , {error LBRACE RBRACE IDENT }]
}
transition on SEMI to state [58]
transition on COMMA to state [57]

-------------------
lalr_state [57]: {
  [VarList ::= VarList COMMA (*) VarName , {SEMI COMMA }]
  [VarName ::= (*) IDENT LBRACKET RBRACKET , {SEMI COMMA }]
  [VarName ::= (*) IDENT , {SEMI COMMA }]
}
transition on IDENT to state [33]
transition on VarName to state [59]

-------------------
lalr_state [58]: {
  [VarDeclStart ::= Type VarList SEMI (*) , {error LBRACE RBRACE IDENT }]
}

-------------------
lalr_state [59]: {
  [VarList ::= VarList COMMA VarName (*) , {SEMI COMMA }]
}

-------------------
lalr_state [60]: {
  [MethodTypeAndName ::= (*) Type IDENT , {LPAREN }]
  [MethodDeclList ::= (*) MethodDeclList MethodDecl , {RBRACE VOID IDENT }]
  [ConstructorDeclStart ::= (*) IDENT LPAREN , {error RPAREN IDENT }]
  [ConstructorDeclList ::= ConstructorDeclList (*) ConstructorDecl , {RBRACE VOID IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [MethodDecl ::= (*) MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [OptionalMethodDeclList ::= (*) , {RBRACE }]
  [ConstructorDecl ::= (*) ConstructorDeclStart FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [MethodTypeAndName ::= (*) VOID IDENT , {LPAREN }]
  [MethodDeclList ::= (*) MethodDecl , {RBRACE VOID IDENT }]
  [OptionalClassMethodDecl ::= LBRACE ConstructorDeclList (*) OptionalMethodDeclList RBRACE , {RBRACE }]
  [OptionalMethodDeclList ::= (*) MethodDeclList , {RBRACE }]
}
transition on MethodDeclList to state [69]
transition on ConstructorDecl to state [68]
transition on VOID to state [67]
transition on MethodDecl to state [66]
transition on MethodTypeAndName to state [65]
transition on OptionalMethodDeclList to state [64]
transition on IDENT to state [63]
transition on ConstructorDeclStart to state [62]
transition on Type to state [61]

-------------------
lalr_state [61]: {
  [MethodTypeAndName ::= Type (*) IDENT , {LPAREN }]
}
transition on IDENT to state [240]

-------------------
lalr_state [62]: {
  [FormalParamDecl ::= (*) Type IDENT LBRACKET RBRACKET , {RPAREN COMMA }]
  [FormalParams ::= (*) , {RPAREN }]
  [FormalParamDecl ::= (*) Type IDENT , {RPAREN COMMA }]
  [FormalParamList ::= (*) FormalParamDecl , {RPAREN COMMA }]
  [Type ::= (*) IDENT , {IDENT }]
  [FormalParams ::= (*) FormalParamList , {RPAREN }]
  [ConstructorDecl ::= ConstructorDeclStart (*) FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [FormalParamList ::= (*) error NT$5 COMMA , {RPAREN COMMA }]
  [FormalParamList ::= (*) FormalParamList COMMA FormalParamDecl , {RPAREN COMMA }]
}
transition on FormalParamDecl to state [77]
transition on IDENT to state [8]
transition on FormalParams to state [234]
transition on FormalParamList to state [75]
transition on error to state [74]
transition on Type to state [73]

-------------------
lalr_state [63]: {
  [Type ::= IDENT (*) , {IDENT }]
  [ConstructorDeclStart ::= IDENT (*) LPAREN , {error RPAREN IDENT }]
}
transition on LPAREN to state [233]

-------------------
lalr_state [64]: {
  [OptionalClassMethodDecl ::= LBRACE ConstructorDeclList OptionalMethodDeclList (*) RBRACE , {RBRACE }]
}
transition on RBRACE to state [232]

-------------------
lalr_state [65]: {
  [MethodDecl ::= MethodTypeAndName (*) LPAREN FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
}
transition on LPAREN to state [72]

-------------------
lalr_state [66]: {
  [MethodDeclList ::= MethodDecl (*) , {RBRACE VOID IDENT }]
}

-------------------
lalr_state [67]: {
  [MethodTypeAndName ::= VOID (*) IDENT , {LPAREN }]
}
transition on IDENT to state [71]

-------------------
lalr_state [68]: {
  [ConstructorDeclList ::= ConstructorDeclList ConstructorDecl (*) , {RBRACE VOID IDENT }]
}

-------------------
lalr_state [69]: {
  [OptionalMethodDeclList ::= MethodDeclList (*) , {RBRACE }]
  [MethodTypeAndName ::= (*) Type IDENT , {LPAREN }]
  [MethodDeclList ::= MethodDeclList (*) MethodDecl , {RBRACE VOID IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [MethodDecl ::= (*) MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [MethodTypeAndName ::= (*) VOID IDENT , {LPAREN }]
}
transition on VOID to state [67]
transition on MethodTypeAndName to state [65]
transition on MethodDecl to state [70]
transition on IDENT to state [8]
transition on Type to state [61]

-------------------
lalr_state [70]: {
  [MethodDeclList ::= MethodDeclList MethodDecl (*) , {RBRACE VOID IDENT }]
}

-------------------
lalr_state [71]: {
  [MethodTypeAndName ::= VOID IDENT (*) , {LPAREN }]
}

-------------------
lalr_state [72]: {
  [FormalParamDecl ::= (*) Type IDENT LBRACKET RBRACKET , {RPAREN COMMA }]
  [FormalParams ::= (*) , {RPAREN }]
  [FormalParamDecl ::= (*) Type IDENT , {RPAREN COMMA }]
  [MethodDecl ::= MethodTypeAndName LPAREN (*) FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [FormalParamList ::= (*) FormalParamDecl , {RPAREN COMMA }]
  [Type ::= (*) IDENT , {IDENT }]
  [FormalParams ::= (*) FormalParamList , {RPAREN }]
  [FormalParamList ::= (*) error NT$5 COMMA , {RPAREN COMMA }]
  [FormalParamList ::= (*) FormalParamList COMMA FormalParamDecl , {RPAREN COMMA }]
}
transition on FormalParamDecl to state [77]
transition on IDENT to state [8]
transition on FormalParams to state [76]
transition on FormalParamList to state [75]
transition on error to state [74]
transition on Type to state [73]

-------------------
lalr_state [73]: {
  [FormalParamDecl ::= Type (*) IDENT , {RPAREN COMMA }]
  [FormalParamDecl ::= Type (*) IDENT LBRACKET RBRACKET , {RPAREN COMMA }]
}
transition on IDENT to state [229]

-------------------
lalr_state [74]: {
  [NT$5 ::= (*) , {COMMA }]
  [FormalParamList ::= error (*) NT$5 COMMA , {RPAREN COMMA }]
}
transition on NT$5 to state [227]

-------------------
lalr_state [75]: {
  [FormalParams ::= FormalParamList (*) , {RPAREN }]
  [FormalParamList ::= FormalParamList (*) COMMA FormalParamDecl , {RPAREN COMMA }]
}
transition on COMMA to state [225]

-------------------
lalr_state [76]: {
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams (*) RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
}
transition on RPAREN to state [78]

-------------------
lalr_state [77]: {
  [FormalParamList ::= FormalParamDecl (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [78]: {
  [VarDeclList ::= (*) VarDeclList VarDeclStart , {error LBRACE IDENT }]
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN (*) VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [VarDeclList ::= (*) , {error LBRACE IDENT }]
}
transition on VarDeclList to state [79]

-------------------
lalr_state [79]: {
  [VarDeclStart ::= (*) error NT$1 LBRACE , {error LBRACE IDENT }]
  [VarDeclStart ::= (*) error NT$0 COMMA , {error LBRACE IDENT }]
  [VarDeclList ::= VarDeclList (*) VarDeclStart , {error LBRACE IDENT }]
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList (*) LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [VarDeclStart ::= (*) error SEMI , {error LBRACE IDENT }]
  [VarDeclStart ::= (*) Type VarList SEMI , {error LBRACE IDENT }]
}
transition on IDENT to state [8]
transition on VarDeclStart to state [47]
transition on error to state [46]
transition on Type to state [45]
transition on LBRACE to state [80]

-------------------
lalr_state [80]: {
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [OptionalStatementList ::= (*) StatementList , {RBRACE }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [OptionalStatementList ::= (*) , {RBRACE }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [StatementList ::= (*) StatementList Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE (*) OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [StatementList ::= (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
}
transition on StatementList to state [105]
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on OptionalStatementList to state [102]
transition on IfKeyWord to state [101]
transition on Statement to state [100]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [81]: {
  [Statement ::= Designator (*) ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Designator ::= Designator (*) DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= Designator (*) INC , {SEMI }]
  [AssignmentStatementExpr ::= Designator (*) ASSIGN Expr , {SEMI }]
  [FunctionName ::= Designator (*) LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [ForeachDesignator ::= Designator (*) DOT , {FOREACH }]
  [DesignatorStatement ::= Designator (*) DEC , {SEMI }]
}
transition on ASSIGN to state [220]
transition on DOT to state [219]
transition on LBRACKET to state [115]
transition on LPAREN to state [147]
transition on DEC to state [218]
transition on INC to state [217]

-------------------
lalr_state [82]: {
  [ControlCondition ::= (*) LPAREN Condition RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= WhileKeyWord (*) ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ControlCondition ::= (*) LPAREN error NT$7 RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [156]
transition on ControlCondition to state [215]

-------------------
lalr_state [83]: {
  [Statement ::= READ (*) LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [211]

-------------------
lalr_state [84]: {
  [Statement ::= CONTINUE (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [210]

-------------------
lalr_state [85]: {
  [Designator ::= IDENT (*) , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [86]: {
  [Statement ::= DesignatorStatement (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [209]

-------------------
lalr_state [87]: {
  [WhileKeyWord ::= WHILE (*) , {LPAREN }]
}

-------------------
lalr_state [88]: {
  [ElseKeyWord ::= (*) ELSE , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= IfConstruct (*) ElseKeyWord Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= IfConstruct (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on ElseKeyWord to state [207]
transition on ELSE to state [206]

-------------------
lalr_state [89]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Statement ::= RETURN (*) Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Term ::= (*) Term Mulop Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) Designator , {SEMI PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {SEMI PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [Statement ::= RETURN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Expr ::= (*) Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) ConstType , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on SEMI to state [204]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [203]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [90]: {
  [IfKeyWord ::= IF (*) , {LPAREN }]
}

-------------------
lalr_state [91]: {
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [OptionalStatementList ::= (*) StatementList , {RBRACE }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [OptionalStatementList ::= (*) , {RBRACE }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [StatementList ::= (*) StatementList Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Statement ::= LBRACE (*) OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [StatementList ::= (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
}
transition on StatementList to state [105]
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on OptionalStatementList to state [201]
transition on IfKeyWord to state [101]
transition on Statement to state [100]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [92]: {
  [ForeachKeyWord ::= (*) FOREACH , {LPAREN }]
  [ForeachConstruct ::= ForeachDesignator (*) ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on FOREACH to state [193]
transition on ForeachKeyWord to state [192]

-------------------
lalr_state [93]: {
  [Statement ::= WhileConstruct (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [94]: {
  [DesignatorStatement ::= FunctionCall (*) , {SEMI }]
}

-------------------
lalr_state [95]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [ActualParameter ::= (*) Expr , {RPAREN COMMA }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= (*) ActualParamList COMMA ActualParameter , {RPAREN COMMA }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) ActualParamList , {RPAREN }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= FunctionName (*) OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= (*) ActualParameter , {RPAREN COMMA }]
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) , {RPAREN }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
}
transition on Term to state [123]
transition on BOOL to state [27]
transition on NEW to state [120]
transition on OptionalMethodActualParams to state [190]
transition on MINUS to state [118]
transition on FunctionName to state [95]
transition on NUMBER to state [25]
transition on FunctionCall to state [121]
transition on LPAREN to state [126]
transition on Expr to state [142]
transition on ActualParameter to state [141]
transition on ActualParamList to state [140]
transition on ConstType to state [127]
transition on CHAR to state [28]
transition on IDENT to state [85]
transition on Factor to state [124]
transition on ClassNewType to state [125]
transition on Designator to state [122]

-------------------
lalr_state [96]: {
  [Statement ::= BREAK (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [189]

-------------------
lalr_state [97]: {
  [DesignatorStatement ::= DesignatorListStart (*) Designator , {SEMI }]
  [Designator ::= (*) IDENT , {LBRACKET SEMI DOT }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET SEMI DOT }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET SEMI DOT }]
}
transition on Designator to state [188]
transition on IDENT to state [85]

-------------------
lalr_state [98]: {
  [Statement ::= PRINT (*) LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= PRINT (*) LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [180]

-------------------
lalr_state [99]: {
  [DesignatorStatement ::= AssignmentStatementExpr (*) , {SEMI }]
}

-------------------
lalr_state [100]: {
  [StatementList ::= Statement (*) , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [101]: {
  [ControlCondition ::= (*) LPAREN Condition RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= IfKeyWord (*) ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ControlCondition ::= (*) LPAREN error NT$7 RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [156]
transition on ControlCondition to state [155]

-------------------
lalr_state [102]: {
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE OptionalStatementList (*) RBRACE , {RBRACE VOID IDENT }]
}
transition on RBRACE to state [154]

-------------------
lalr_state [103]: {
  [DesignatorListStart ::= DesignatorListStartDummy (*) LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
}
transition on LBRACKET to state [107]

-------------------
lalr_state [104]: {
  [Statement ::= ForeachConstruct (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [105]: {
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [StatementList ::= StatementList (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [OptionalStatementList ::= StatementList (*) , {RBRACE }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
}
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on IfKeyWord to state [101]
transition on Statement to state [106]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [106]: {
  [StatementList ::= StatementList Statement (*) , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [107]: {
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorListStart ::= DesignatorListStartDummy LBRACKET (*) DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [DesignatorListContent ::= (*) DesignatorDummy , {RBRACKET COMMA }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorDummy ::= (*) Designator , {RBRACKET COMMA }]
  [DesignatorListContent ::= (*) DesignatorListContent COMMA DesignatorDummy , {RBRACKET COMMA }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorDummy ::= (*) , {RBRACKET COMMA }]
}
transition on IDENT to state [85]
transition on DesignatorListContent to state [110]
transition on Designator to state [109]
transition on DesignatorDummy to state [108]

-------------------
lalr_state [108]: {
  [DesignatorListContent ::= DesignatorDummy (*) , {RBRACKET COMMA }]
}

-------------------
lalr_state [109]: {
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorDummy ::= Designator (*) , {RBRACKET COMMA }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET RBRACKET COMMA DOT }]
}
transition on DOT to state [116]
transition on LBRACKET to state [115]

-------------------
lalr_state [110]: {
  [DesignatorListStart ::= DesignatorListStartDummy LBRACKET DesignatorListContent (*) RBRACKET ASSIGN , {IDENT }]
  [DesignatorListContent ::= DesignatorListContent (*) COMMA DesignatorDummy , {RBRACKET COMMA }]
}
transition on RBRACKET to state [112]
transition on COMMA to state [111]

-------------------
lalr_state [111]: {
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorListContent ::= DesignatorListContent COMMA (*) DesignatorDummy , {RBRACKET COMMA }]
  [DesignatorDummy ::= (*) Designator , {RBRACKET COMMA }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET COMMA DOT }]
  [DesignatorDummy ::= (*) , {RBRACKET COMMA }]
}
transition on IDENT to state [85]
transition on Designator to state [109]
transition on DesignatorDummy to state [114]

-------------------
lalr_state [112]: {
  [DesignatorListStart ::= DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET (*) ASSIGN , {IDENT }]
}
transition on ASSIGN to state [113]

-------------------
lalr_state [113]: {
  [DesignatorListStart ::= DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN (*) , {IDENT }]
}

-------------------
lalr_state [114]: {
  [DesignatorListContent ::= DesignatorListContent COMMA DesignatorDummy (*) , {RBRACKET COMMA }]
}

-------------------
lalr_state [115]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) Designator , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= Designator LBRACKET (*) Expr RBRACKET , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) ConstType , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [119]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [116]: {
  [Designator ::= Designator DOT (*) IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on IDENT to state [117]

-------------------
lalr_state [117]: {
  [Designator ::= Designator DOT IDENT (*) , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [118]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= MINUS (*) Term , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [153]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on BOOL to state [27]
transition on IDENT to state [85]

-------------------
lalr_state [119]: {
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Designator ::= Designator LBRACKET Expr (*) RBRACKET , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= Expr (*) Addop Term , {RBRACKET PLUS MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on RBRACKET to state [152]
transition on PLUS to state [130]

-------------------
lalr_state [120]: {
  [ClassNewType ::= NEW (*) Type , {LPAREN }]
  [Factor ::= NEW (*) Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Type ::= (*) IDENT , {LBRACKET LPAREN }]
}
transition on IDENT to state [8]
transition on Type to state [148]

-------------------
lalr_state [121]: {
  [Factor ::= FunctionCall (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [122]: {
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionName ::= Designator (*) LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= Designator (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on DOT to state [116]
transition on LBRACKET to state [115]
transition on LPAREN to state [147]

-------------------
lalr_state [123]: {
  [Mulop ::= (*) MOD , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Term (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Mulop ::= (*) DIV , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Mulop ::= (*) MUL , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Term ::= Term (*) Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on Mulop to state [137]
transition on DIV to state [136]
transition on MUL to state [135]
transition on MOD to state [134]

-------------------
lalr_state [124]: {
  [Term ::= Factor (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [125]: {
  [Factor ::= ClassNewType (*) LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on LPAREN to state [139]

-------------------
lalr_state [126]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Term , {RPAREN PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS }]
  [Factor ::= LPAREN (*) Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [128]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [127]: {
  [Factor ::= ConstType (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [128]: {
  [Factor ::= LPAREN Expr (*) RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Expr (*) Addop Term , {RPAREN PLUS MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on PLUS to state [130]
transition on RPAREN to state [129]

-------------------
lalr_state [129]: {
  [Factor ::= LPAREN Expr RPAREN (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [130]: {
  [Addop ::= PLUS (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [131]: {
  [Addop ::= MINUS (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [132]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= Expr Addop (*) Term , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [133]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on BOOL to state [27]
transition on IDENT to state [85]

-------------------
lalr_state [133]: {
  [Mulop ::= (*) MOD , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Mulop ::= (*) DIV , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Expr Addop Term (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Mulop ::= (*) MUL , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Term ::= Term (*) Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on Mulop to state [137]
transition on DIV to state [136]
transition on MUL to state [135]
transition on MOD to state [134]

-------------------
lalr_state [134]: {
  [Mulop ::= MOD (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [135]: {
  [Mulop ::= MUL (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [136]: {
  [Mulop ::= DIV (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}

-------------------
lalr_state [137]: {
  [Term ::= Term Mulop (*) Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) NUMBER , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) BOOL , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [138]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on BOOL to state [27]
transition on IDENT to state [85]

-------------------
lalr_state [138]: {
  [Term ::= Term Mulop Factor (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [139]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [ActualParameter ::= (*) Expr , {RPAREN COMMA }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= (*) ActualParamList COMMA ActualParameter , {RPAREN COMMA }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) ActualParamList , {RPAREN }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= ClassNewType LPAREN (*) OptionalMethodActualParams RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ActualParamList ::= (*) ActualParameter , {RPAREN COMMA }]
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [OptionalMethodActualParams ::= (*) , {RPAREN }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
}
transition on Term to state [123]
transition on BOOL to state [27]
transition on NEW to state [120]
transition on OptionalMethodActualParams to state [143]
transition on MINUS to state [118]
transition on FunctionName to state [95]
transition on NUMBER to state [25]
transition on FunctionCall to state [121]
transition on LPAREN to state [126]
transition on Expr to state [142]
transition on ActualParameter to state [141]
transition on ActualParamList to state [140]
transition on ConstType to state [127]
transition on CHAR to state [28]
transition on IDENT to state [85]
transition on Factor to state [124]
transition on ClassNewType to state [125]
transition on Designator to state [122]

-------------------
lalr_state [140]: {
  [OptionalMethodActualParams ::= ActualParamList (*) , {RPAREN }]
  [ActualParamList ::= ActualParamList (*) COMMA ActualParameter , {RPAREN COMMA }]
}
transition on COMMA to state [145]

-------------------
lalr_state [141]: {
  [ActualParamList ::= ActualParameter (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [142]: {
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Expr (*) Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [ActualParameter ::= Expr (*) , {RPAREN COMMA }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on PLUS to state [130]

-------------------
lalr_state [143]: {
  [Factor ::= ClassNewType LPAREN OptionalMethodActualParams (*) RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on RPAREN to state [144]

-------------------
lalr_state [144]: {
  [Factor ::= ClassNewType LPAREN OptionalMethodActualParams RPAREN (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [145]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [ActualParameter ::= (*) Expr , {RPAREN COMMA }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ActualParamList ::= ActualParamList COMMA (*) ActualParameter , {RPAREN COMMA }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on ActualParameter to state [146]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [142]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [146]: {
  [ActualParamList ::= ActualParamList COMMA ActualParameter (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [147]: {
  [FunctionName ::= Designator LPAREN (*) , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [148]: {
  [Factor ::= NEW Type (*) LBRACKET Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ClassNewType ::= NEW Type (*) , {LPAREN }]
}
transition on LBRACKET to state [149]

-------------------
lalr_state [149]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Factor ::= NEW Type LBRACKET (*) Expr RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Term Mulop Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) Designator , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RBRACKET LPAREN DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RBRACKET PLUS MINUS }]
  [Factor ::= (*) ConstType , {RBRACKET PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RBRACKET PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [150]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [150]: {
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Expr (*) Addop Term , {RBRACKET PLUS MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Factor ::= NEW Type LBRACKET Expr (*) RBRACKET , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on RBRACKET to state [151]
transition on PLUS to state [130]

-------------------
lalr_state [151]: {
  [Factor ::= NEW Type LBRACKET Expr RBRACKET (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [152]: {
  [Designator ::= Designator LBRACKET Expr RBRACKET (*) , {ASSIGN LBRACKET RBRACKET LPAREN RPAREN SEMI COMMA DOT PLUS MINUS INC DEC MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [153]: {
  [Mulop ::= (*) MOD , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Mulop ::= (*) DIV , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Mulop ::= (*) MUL , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= MINUS Term (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Term ::= Term (*) Mulop Factor , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on Mulop to state [137]
transition on DIV to state [136]
transition on MUL to state [135]
transition on MOD to state [134]

-------------------
lalr_state [154]: {
  [MethodDecl ::= MethodTypeAndName LPAREN FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE (*) , {RBRACE VOID IDENT }]
}

-------------------
lalr_state [155]: {
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= IfKeyWord ControlCondition (*) Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
}
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on Statement to state [179]
transition on IfKeyWord to state [101]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [156]: {
  [ConditionFactor ::= (*) Expr Relop Expr , {RPAREN OR AND }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ControlCondition ::= LPAREN (*) Condition RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionTerm AndKeyWord ConditionFactor , {RPAREN OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [Condition ::= (*) Condition OrKeyWord ConditionTerm , {RPAREN OR }]
  [ConditionFactor ::= (*) Expr , {RPAREN OR AND }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionFactor , {RPAREN OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Condition ::= (*) ConditionTerm , {RPAREN OR }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ControlCondition ::= LPAREN (*) error NT$7 RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on ConditionTerm to state [161]
transition on ConditionFactor to state [160]
transition on Condition to state [159]
transition on Term to state [123]
transition on BOOL to state [27]
transition on NEW to state [120]
transition on error to state [158]
transition on MINUS to state [118]
transition on FunctionName to state [95]
transition on NUMBER to state [25]
transition on FunctionCall to state [121]
transition on LPAREN to state [126]
transition on Expr to state [157]
transition on ConstType to state [127]
transition on CHAR to state [28]
transition on IDENT to state [85]
transition on Factor to state [124]
transition on ClassNewType to state [125]
transition on Designator to state [122]

-------------------
lalr_state [157]: {
  [ConditionFactor ::= Expr (*) , {RPAREN OR AND }]
  [Relop ::= (*) LT , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Relop ::= (*) EQ , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [ConditionFactor ::= Expr (*) Relop Expr , {RPAREN OR AND }]
  [Relop ::= (*) LE , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Relop ::= (*) GT , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Expr (*) Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Relop ::= (*) GE , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Relop ::= (*) NE , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on LT to state [177]
transition on NE to state [176]
transition on GT to state [175]
transition on LE to state [174]
transition on Addop to state [132]
transition on Relop to state [173]
transition on EQ to state [172]
transition on PLUS to state [130]
transition on GE to state [171]
transition on MINUS to state [131]

-------------------
lalr_state [158]: {
  [NT$7 ::= (*) , {RPAREN }]
  [ControlCondition ::= LPAREN error (*) NT$7 RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on NT$7 to state [169]

-------------------
lalr_state [159]: {
  [OrKeyWord ::= (*) OR , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Condition ::= Condition (*) OrKeyWord ConditionTerm , {RPAREN OR }]
  [ControlCondition ::= LPAREN Condition (*) RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on OrKeyWord to state [167]
transition on OR to state [166]
transition on RPAREN to state [165]

-------------------
lalr_state [160]: {
  [ConditionTerm ::= ConditionFactor (*) , {RPAREN OR AND }]
}

-------------------
lalr_state [161]: {
  [ConditionTerm ::= ConditionTerm (*) AndKeyWord ConditionFactor , {RPAREN OR AND }]
  [AndKeyWord ::= (*) AND , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Condition ::= ConditionTerm (*) , {RPAREN OR }]
}
transition on AndKeyWord to state [163]
transition on AND to state [162]

-------------------
lalr_state [162]: {
  [AndKeyWord ::= AND (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [163]: {
  [ConditionFactor ::= (*) Expr Relop Expr , {RPAREN OR AND }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= ConditionTerm AndKeyWord (*) ConditionFactor , {RPAREN OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConditionFactor ::= (*) Expr , {RPAREN OR AND }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on ConditionFactor to state [164]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [157]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [164]: {
  [ConditionTerm ::= ConditionTerm AndKeyWord ConditionFactor (*) , {RPAREN OR AND }]
}

-------------------
lalr_state [165]: {
  [ControlCondition ::= LPAREN Condition RPAREN (*) , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [166]: {
  [OrKeyWord ::= OR (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [167]: {
  [ConditionFactor ::= (*) Expr Relop Expr , {RPAREN OR AND }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionTerm AndKeyWord ConditionFactor , {RPAREN OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Condition ::= Condition OrKeyWord (*) ConditionTerm , {RPAREN OR }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConditionFactor ::= (*) Expr , {RPAREN OR AND }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConditionTerm ::= (*) ConditionFactor , {RPAREN OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on ConditionFactor to state [160]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [157]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on ConditionTerm to state [168]
transition on MINUS to state [118]

-------------------
lalr_state [168]: {
  [Condition ::= Condition OrKeyWord ConditionTerm (*) , {RPAREN OR }]
  [ConditionTerm ::= ConditionTerm (*) AndKeyWord ConditionFactor , {RPAREN OR AND }]
  [AndKeyWord ::= (*) AND , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}
transition on AndKeyWord to state [163]
transition on AND to state [162]

-------------------
lalr_state [169]: {
  [ControlCondition ::= LPAREN error NT$7 (*) RPAREN , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}
transition on RPAREN to state [170]

-------------------
lalr_state [170]: {
  [ControlCondition ::= LPAREN error NT$7 RPAREN (*) , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [171]: {
  [Relop ::= GE (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [172]: {
  [Relop ::= EQ (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [173]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ConstType ::= (*) BOOL , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD OR AND }]
  [Expr ::= (*) Expr Addop Term , {RPAREN PLUS MINUS OR AND }]
  [Factor ::= (*) Designator , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD OR AND }]
  [Term ::= (*) Factor , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Factor ::= (*) FunctionCall , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Expr ::= (*) Term , {RPAREN PLUS MINUS OR AND }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ConstType ::= (*) CHAR , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN DOT PLUS MINUS MUL DIV MOD OR AND }]
  [Expr ::= (*) MINUS Term , {RPAREN PLUS MINUS OR AND }]
  [Factor ::= (*) ConstType , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN PLUS MINUS MUL DIV MOD OR AND }]
  [ConditionFactor ::= Expr Relop (*) Expr , {RPAREN OR AND }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [178]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [174]: {
  [Relop ::= LE (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [175]: {
  [Relop ::= GT (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [176]: {
  [Relop ::= NE (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [177]: {
  [Relop ::= LT (*) , {LPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
}

-------------------
lalr_state [178]: {
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [ConditionFactor ::= Expr Relop Expr (*) , {RPAREN OR AND }]
  [Expr ::= Expr (*) Addop Term , {RPAREN PLUS MINUS OR AND }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on PLUS to state [130]

-------------------
lalr_state [179]: {
  [IfConstruct ::= IfKeyWord ControlCondition Statement (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [180]: {
  [Statement ::= PRINT LPAREN (*) Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Term ::= (*) Term Mulop Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) Designator , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Statement ::= PRINT LPAREN (*) Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN RPAREN COMMA DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {RPAREN COMMA PLUS MINUS }]
  [Factor ::= (*) ConstType , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN COMMA PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on Factor to state [124]
transition on Term to state [123]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [181]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [181]: {
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Statement ::= PRINT LPAREN Expr (*) COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Expr ::= Expr (*) Addop Term , {RPAREN COMMA PLUS MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Statement ::= PRINT LPAREN Expr (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on PLUS to state [130]
transition on RPAREN to state [183]
transition on COMMA to state [182]

-------------------
lalr_state [182]: {
  [Statement ::= PRINT LPAREN Expr COMMA (*) NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on NUMBER to state [185]

-------------------
lalr_state [183]: {
  [Statement ::= PRINT LPAREN Expr RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [184]

-------------------
lalr_state [184]: {
  [Statement ::= PRINT LPAREN Expr RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [185]: {
  [Statement ::= PRINT LPAREN Expr COMMA NUMBER (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on RPAREN to state [186]

-------------------
lalr_state [186]: {
  [Statement ::= PRINT LPAREN Expr COMMA NUMBER RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [187]

-------------------
lalr_state [187]: {
  [Statement ::= PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [188]: {
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET SEMI DOT }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET SEMI DOT }]
  [DesignatorStatement ::= DesignatorListStart Designator (*) , {SEMI }]
}
transition on DOT to state [116]
transition on LBRACKET to state [115]

-------------------
lalr_state [189]: {
  [Statement ::= BREAK SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [190]: {
  [FunctionCall ::= FunctionName OptionalMethodActualParams (*) RPAREN , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}
transition on RPAREN to state [191]

-------------------
lalr_state [191]: {
  [FunctionCall ::= FunctionName OptionalMethodActualParams RPAREN (*) , {RBRACKET RPAREN SEMI COMMA PLUS MINUS MUL DIV MOD EQ NE GT GE LT LE OR AND }]
}

-------------------
lalr_state [192]: {
  [ForeachConstruct ::= ForeachDesignator ForeachKeyWord (*) LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on LPAREN to state [194]

-------------------
lalr_state [193]: {
  [ForeachKeyWord ::= FOREACH (*) , {LPAREN }]
}

-------------------
lalr_state [194]: {
  [ForIdent ::= (*) IDENT , {ARROW }]
  [ForeachConstruct ::= ForeachDesignator ForeachKeyWord LPAREN (*) ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on IDENT to state [196]
transition on ForIdent to state [195]

-------------------
lalr_state [195]: {
  [ForeachConstruct ::= ForeachDesignator ForeachKeyWord LPAREN ForIdent (*) ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on ARROW to state [197]

-------------------
lalr_state [196]: {
  [ForIdent ::= IDENT (*) , {ARROW }]
}

-------------------
lalr_state [197]: {
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {RPAREN }]
  [Statement ::= (*) RETURN Expr SEMI , {RPAREN }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {RPAREN }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {RPAREN }]
  [Statement ::= (*) CONTINUE SEMI , {RPAREN }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {RPAREN }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [ForeachConstruct ::= ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW (*) Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {RPAREN }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {RPAREN }]
  [Statement ::= (*) IfConstruct , {RPAREN }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {RPAREN ELSE }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {RPAREN }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {RPAREN }]
  [Statement ::= (*) RETURN SEMI , {RPAREN }]
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {RPAREN }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {RPAREN }]
  [Statement ::= (*) BREAK SEMI , {RPAREN }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {RPAREN }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
}
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on Statement to state [198]
transition on IfKeyWord to state [101]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [198]: {
  [ForeachConstruct ::= ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on RPAREN to state [199]

-------------------
lalr_state [199]: {
  [ForeachConstruct ::= ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [200]

-------------------
lalr_state [200]: {
  [ForeachConstruct ::= ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [201]: {
  [Statement ::= LBRACE OptionalStatementList (*) RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on RBRACE to state [202]

-------------------
lalr_state [202]: {
  [Statement ::= LBRACE OptionalStatementList RBRACE (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [203]: {
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Expr ::= Expr (*) Addop Term , {SEMI PLUS MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [Statement ::= RETURN Expr (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on SEMI to state [205]
transition on PLUS to state [130]

-------------------
lalr_state [204]: {
  [Statement ::= RETURN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [205]: {
  [Statement ::= RETURN Expr SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [206]: {
  [ElseKeyWord ::= ELSE (*) , {LBRACKET LBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [207]: {
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= IfConstruct ElseKeyWord (*) Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
}
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on IfKeyWord to state [101]
transition on Statement to state [208]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [208]: {
  [Statement ::= IfConstruct ElseKeyWord Statement (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [209]: {
  [Statement ::= DesignatorStatement SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [210]: {
  [Statement ::= CONTINUE SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [211]: {
  [Designator ::= (*) IDENT , {LBRACKET RPAREN DOT }]
  [Statement ::= READ LPAREN (*) Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET RPAREN DOT }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET RPAREN DOT }]
}
transition on IDENT to state [85]
transition on Designator to state [212]

-------------------
lalr_state [212]: {
  [Statement ::= READ LPAREN Designator (*) RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Designator ::= Designator (*) DOT IDENT , {LBRACKET RPAREN DOT }]
  [Designator ::= Designator (*) LBRACKET Expr RBRACKET , {LBRACKET RPAREN DOT }]
}
transition on DOT to state [116]
transition on LBRACKET to state [115]
transition on RPAREN to state [213]

-------------------
lalr_state [213]: {
  [Statement ::= READ LPAREN Designator RPAREN (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [214]

-------------------
lalr_state [214]: {
  [Statement ::= READ LPAREN Designator RPAREN SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [215]: {
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= WhileKeyWord ControlCondition (*) Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
}
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on IfKeyWord to state [101]
transition on Statement to state [216]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [216]: {
  [WhileConstruct ::= WhileKeyWord ControlCondition Statement (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [217]: {
  [DesignatorStatement ::= Designator INC (*) , {SEMI }]
}

-------------------
lalr_state [218]: {
  [DesignatorStatement ::= Designator DEC (*) , {SEMI }]
}

-------------------
lalr_state [219]: {
  [Designator ::= Designator DOT (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [ForeachDesignator ::= Designator DOT (*) , {FOREACH }]
}
transition on IDENT to state [117]

-------------------
lalr_state [220]: {
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [Statement ::= Designator ASSIGN (*) error NT$6 SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Term ::= (*) Term Mulop Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) NEW Type LBRACKET Expr RBRACKET , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) BOOL , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator DOT IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Expr Addop Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) Designator , {SEMI PLUS MINUS MUL DIV MOD }]
  [ClassNewType ::= (*) NEW Type , {LPAREN }]
  [ConstType ::= (*) NUMBER , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) IDENT , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Term ::= (*) Factor , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) FunctionCall , {SEMI PLUS MINUS MUL DIV MOD }]
  [AssignmentStatementExpr ::= Designator ASSIGN (*) Expr , {SEMI }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) ClassNewType LPAREN OptionalMethodActualParams RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
  [ConstType ::= (*) CHAR , {SEMI PLUS MINUS MUL DIV MOD }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {LBRACKET LPAREN SEMI DOT PLUS MINUS MUL DIV MOD }]
  [Expr ::= (*) MINUS Term , {SEMI PLUS MINUS }]
  [Factor ::= (*) ConstType , {SEMI PLUS MINUS MUL DIV MOD }]
  [Factor ::= (*) LPAREN Expr RPAREN , {SEMI PLUS MINUS MUL DIV MOD }]
}
transition on CHAR to state [28]
transition on ConstType to state [127]
transition on LPAREN to state [126]
transition on ClassNewType to state [125]
transition on error to state [222]
transition on Factor to state [124]
transition on Term to state [123]
transition on NUMBER to state [25]
transition on FunctionName to state [95]
transition on Designator to state [122]
transition on FunctionCall to state [121]
transition on NEW to state [120]
transition on Expr to state [221]
transition on BOOL to state [27]
transition on IDENT to state [85]
transition on MINUS to state [118]

-------------------
lalr_state [221]: {
  [Addop ::= (*) MINUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
  [AssignmentStatementExpr ::= Designator ASSIGN Expr (*) , {SEMI }]
  [Expr ::= Expr (*) Addop Term , {SEMI PLUS MINUS }]
  [Addop ::= (*) PLUS , {LPAREN NEW NUMBER CHAR BOOL IDENT }]
}
transition on Addop to state [132]
transition on MINUS to state [131]
transition on PLUS to state [130]

-------------------
lalr_state [222]: {
  [NT$6 ::= (*) , {SEMI }]
  [Statement ::= Designator ASSIGN error (*) NT$6 SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on NT$6 to state [223]

-------------------
lalr_state [223]: {
  [Statement ::= Designator ASSIGN error NT$6 (*) SEMI , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}
transition on SEMI to state [224]

-------------------
lalr_state [224]: {
  [Statement ::= Designator ASSIGN error NT$6 SEMI (*) , {LBRACKET LBRACE RBRACE RPAREN PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
}

-------------------
lalr_state [225]: {
  [FormalParamDecl ::= (*) Type IDENT LBRACKET RBRACKET , {RPAREN COMMA }]
  [FormalParamDecl ::= (*) Type IDENT , {RPAREN COMMA }]
  [Type ::= (*) IDENT , {IDENT }]
  [FormalParamList ::= FormalParamList COMMA (*) FormalParamDecl , {RPAREN COMMA }]
}
transition on FormalParamDecl to state [226]
transition on IDENT to state [8]
transition on Type to state [73]

-------------------
lalr_state [226]: {
  [FormalParamList ::= FormalParamList COMMA FormalParamDecl (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [227]: {
  [FormalParamList ::= error NT$5 (*) COMMA , {RPAREN COMMA }]
}
transition on COMMA to state [228]

-------------------
lalr_state [228]: {
  [FormalParamList ::= error NT$5 COMMA (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [229]: {
  [FormalParamDecl ::= Type IDENT (*) , {RPAREN COMMA }]
  [FormalParamDecl ::= Type IDENT (*) LBRACKET RBRACKET , {RPAREN COMMA }]
}
transition on LBRACKET to state [230]

-------------------
lalr_state [230]: {
  [FormalParamDecl ::= Type IDENT LBRACKET (*) RBRACKET , {RPAREN COMMA }]
}
transition on RBRACKET to state [231]

-------------------
lalr_state [231]: {
  [FormalParamDecl ::= Type IDENT LBRACKET RBRACKET (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [232]: {
  [OptionalClassMethodDecl ::= LBRACE ConstructorDeclList OptionalMethodDeclList RBRACE (*) , {RBRACE }]
}

-------------------
lalr_state [233]: {
  [ConstructorDeclStart ::= IDENT LPAREN (*) , {error RPAREN IDENT }]
}

-------------------
lalr_state [234]: {
  [ConstructorDecl ::= ConstructorDeclStart FormalParams (*) RPAREN VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
}
transition on RPAREN to state [235]

-------------------
lalr_state [235]: {
  [VarDeclList ::= (*) VarDeclList VarDeclStart , {error LBRACE IDENT }]
  [ConstructorDecl ::= ConstructorDeclStart FormalParams RPAREN (*) VarDeclList LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [VarDeclList ::= (*) , {error LBRACE IDENT }]
}
transition on VarDeclList to state [236]

-------------------
lalr_state [236]: {
  [VarDeclStart ::= (*) error NT$1 LBRACE , {error LBRACE IDENT }]
  [VarDeclStart ::= (*) error NT$0 COMMA , {error LBRACE IDENT }]
  [VarDeclList ::= VarDeclList (*) VarDeclStart , {error LBRACE IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [ConstructorDecl ::= ConstructorDeclStart FormalParams RPAREN VarDeclList (*) LBRACE OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [VarDeclStart ::= (*) error SEMI , {error LBRACE IDENT }]
  [VarDeclStart ::= (*) Type VarList SEMI , {error LBRACE IDENT }]
}
transition on IDENT to state [8]
transition on VarDeclStart to state [47]
transition on error to state [46]
transition on Type to state [45]
transition on LBRACE to state [237]

-------------------
lalr_state [237]: {
  [WhileConstruct ::= (*) WhileKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) RETURN Expr SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) DesignatorStatement SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [FunctionCall ::= (*) FunctionName OptionalMethodActualParams RPAREN , {SEMI }]
  [DesignatorListStart ::= (*) DesignatorListStartDummy LBRACKET DesignatorListContent RBRACKET ASSIGN , {IDENT }]
  [ForeachDesignator ::= (*) Designator DOT , {FOREACH }]
  [Statement ::= (*) Designator ASSIGN error NT$6 SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [OptionalStatementList ::= (*) StatementList , {RBRACE }]
  [DesignatorStatement ::= (*) FunctionCall , {SEMI }]
  [WhileKeyWord ::= (*) WHILE , {LPAREN }]
  [Statement ::= (*) IfConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) WhileConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [FunctionName ::= (*) Designator LPAREN , {LPAREN RPAREN NEW NUMBER CHAR BOOL IDENT MINUS }]
  [DesignatorListStartDummy ::= (*) , {LBRACKET }]
  [ConstructorDecl ::= ConstructorDeclStart FormalParams RPAREN VarDeclList LBRACE (*) OptionalStatementList RBRACE , {RBRACE VOID IDENT }]
  [IfConstruct ::= (*) IfKeyWord ControlCondition Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF ELSE CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) BREAK SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [OptionalStatementList ::= (*) , {RBRACE }]
  [Designator ::= (*) IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= (*) Designator INC , {SEMI }]
  [ForeachConstruct ::= (*) ForeachDesignator ForeachKeyWord LPAREN ForIdent ARROW Statement RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) IfConstruct ElseKeyWord Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) ForeachConstruct , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [IfKeyWord ::= (*) IF , {LPAREN }]
  [Statement ::= (*) CONTINUE SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [StatementList ::= (*) StatementList Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator LBRACKET Expr RBRACKET , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [DesignatorStatement ::= (*) Designator DEC , {SEMI }]
  [Statement ::= (*) LBRACE OptionalStatementList RBRACE , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Statement ::= (*) PRINT LPAREN Expr RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) AssignmentStatementExpr , {SEMI }]
  [Statement ::= (*) RETURN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [StatementList ::= (*) Statement , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [Designator ::= (*) Designator DOT IDENT , {ASSIGN LBRACKET LPAREN DOT INC DEC }]
  [AssignmentStatementExpr ::= (*) Designator ASSIGN Expr , {SEMI }]
  [Statement ::= (*) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI , {LBRACKET LBRACE RBRACE PRINT READ WHILE IF CONTINUE BREAK RETURN IDENT }]
  [DesignatorStatement ::= (*) DesignatorListStart Designator , {SEMI }]
}
transition on StatementList to state [105]
transition on ForeachConstruct to state [104]
transition on DesignatorListStartDummy to state [103]
transition on OptionalStatementList to state [238]
transition on IfKeyWord to state [101]
transition on Statement to state [100]
transition on AssignmentStatementExpr to state [99]
transition on PRINT to state [98]
transition on DesignatorListStart to state [97]
transition on BREAK to state [96]
transition on FunctionName to state [95]
transition on FunctionCall to state [94]
transition on WhileConstruct to state [93]
transition on ForeachDesignator to state [92]
transition on LBRACE to state [91]
transition on IF to state [90]
transition on RETURN to state [89]
transition on IfConstruct to state [88]
transition on WHILE to state [87]
transition on DesignatorStatement to state [86]
transition on IDENT to state [85]
transition on CONTINUE to state [84]
transition on READ to state [83]
transition on WhileKeyWord to state [82]
transition on Designator to state [81]

-------------------
lalr_state [238]: {
  [ConstructorDecl ::= ConstructorDeclStart FormalParams RPAREN VarDeclList LBRACE OptionalStatementList (*) RBRACE , {RBRACE VOID IDENT }]
}
transition on RBRACE to state [239]

-------------------
lalr_state [239]: {
  [ConstructorDecl ::= ConstructorDeclStart FormalParams RPAREN VarDeclList LBRACE OptionalStatementList RBRACE (*) , {RBRACE VOID IDENT }]
}

-------------------
lalr_state [240]: {
  [MethodTypeAndName ::= Type IDENT (*) , {LPAREN }]
}

-------------------
lalr_state [241]: {
  [OptionalClassMethodDecl ::= (*) LBRACE ConstructorDeclList OptionalMethodDeclList RBRACE , {RBRACE }]
  [VarDeclStart ::= (*) error SEMI , {error LBRACE RBRACE IDENT }]
  [VarDeclStart ::= (*) Type VarList SEMI , {error LBRACE RBRACE IDENT }]
  [ProgClassDecl ::= ClassName error VarDeclList (*) OptionalClassMethodDecl RBRACE , {error LBRACE CONST IDENT CLASS }]
  [VarDeclStart ::= (*) error NT$1 LBRACE , {error LBRACE RBRACE IDENT }]
  [VarDeclStart ::= (*) error NT$0 COMMA , {error LBRACE RBRACE IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [VarDeclList ::= VarDeclList (*) VarDeclStart , {error LBRACE RBRACE IDENT }]
  [OptionalClassMethodDecl ::= (*) , {RBRACE }]
}
transition on OptionalClassMethodDecl to state [242]
transition on IDENT to state [8]
transition on VarDeclStart to state [47]
transition on error to state [46]
transition on Type to state [45]
transition on LBRACE to state [44]

-------------------
lalr_state [242]: {
  [ProgClassDecl ::= ClassName error VarDeclList OptionalClassMethodDecl (*) RBRACE , {error LBRACE CONST IDENT CLASS }]
}
transition on RBRACE to state [243]

-------------------
lalr_state [243]: {
  [ProgClassDecl ::= ClassName error VarDeclList OptionalClassMethodDecl RBRACE (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [244]: {
  [OptionalClassExtends ::= EXT SuperClass (*) , {LBRACE }]
}

-------------------
lalr_state [245]: {
  [NT$4 ::= (*) , {LBRACE }]
  [OptionalClassExtends ::= EXT error (*) NT$4 LBRACE , {LBRACE }]
}
transition on NT$4 to state [247]

-------------------
lalr_state [246]: {
  [SuperClass ::= IDENT (*) , {LBRACE }]
}

-------------------
lalr_state [247]: {
  [OptionalClassExtends ::= EXT error NT$4 (*) LBRACE , {LBRACE }]
}
transition on LBRACE to state [248]

-------------------
lalr_state [248]: {
  [OptionalClassExtends ::= EXT error NT$4 LBRACE (*) , {LBRACE }]
}

-------------------
lalr_state [249]: {
  [ProgVarDeclStart ::= error NT$3 (*) SEMI , {error LBRACE CONST IDENT CLASS }]
}
transition on SEMI to state [252]

-------------------
lalr_state [250]: {
  [ProgVarDeclStart ::= error NT$2 (*) COMMA , {error LBRACE CONST IDENT CLASS }]
}
transition on COMMA to state [251]

-------------------
lalr_state [251]: {
  [ProgVarDeclStart ::= error NT$2 COMMA (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [252]: {
  [ProgVarDeclStart ::= error NT$3 SEMI (*) , {error LBRACE CONST IDENT CLASS }]
}

-------------------
lalr_state [253]: {
  [Program ::= PROG ProgName ProgDeclList LBRACE OptionalMethodDeclList (*) RBRACE , {EOF }]
}
transition on RBRACE to state [254]

-------------------
lalr_state [254]: {
  [Program ::= PROG ProgName ProgDeclList LBRACE OptionalMethodDeclList RBRACE (*) , {EOF }]
}

-------------------
lalr_state [255]: {
  [$START ::= Program EOF (*) , {EOF }]
}

-------------------
Closing files...
------- CUP v0.10k Parser Generation Summary -------
  0 errors and 1 warning
  48 terminals, 77 non-terminals, and 149 productions declared, 
  producing 256 unique parse states.
  1 terminal declared but not used.
  0 non-terminal declared but not used.
  0 productions never reduced.
  0 conflicts detected (0 expected).
  Code written to "MJParser.java", and "sym.java".
---------------------------------------------------- (v0.10k)
